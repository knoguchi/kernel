//! 8x16 VGA-style bitmap font
//!
//! Each character is 8 pixels wide and 16 pixels tall.
//! The font data is stored as 16 bytes per character (one byte per row).
//! Each bit in a byte represents one pixel (MSB = leftmost pixel).

use crate::ramfb::Ramfb;
use crate::virtio_gpu::VirtioGpu;

/// Font dimensions
pub const FONT_WIDTH: u32 = 8;
pub const FONT_HEIGHT: u32 = 16;

/// Number of characters in the font (ASCII 0-127 + extended)
pub const FONT_CHARS: usize = 256;

/// Font data: 256 characters * 16 bytes per character = 4096 bytes
/// This is a classic VGA 8x16 font covering ASCII and extended characters.
pub static FONT_DATA: [u8; 4096] = [
    // Character 0x00 (null)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x01
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x02
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x03
    0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
    // Character 0x04
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x05
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x06
    0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x07 (bell)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x08 (backspace)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    // Character 0x09 (tab)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x0A (newline)
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    // Character 0x0B
    0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // Character 0x0C
    0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x0D (carriage return)
    0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
    // Character 0x0E
    0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00,
    // Character 0x0F
    0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x10
    0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    // Character 0x11
    0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E, 0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    // Character 0x12
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x13
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // Character 0x14
    0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00,
    // Character 0x15
    0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00,
    // Character 0x16
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x17
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x18
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x19
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1E
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x1F
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x20 (space)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x21 '!'
    0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x22 '"'
    0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x23 '#'
    0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x24 '$'
    0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00,
    // Character 0x25 '%'
    0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
    // Character 0x26 '&'
    0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // Character 0x27 '''
    0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x28 '('
    0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x29 ')'
    0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2A '*'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2B '+'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2C ','
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    // Character 0x2D '-'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2E '.'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2F '/'
    0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
    // Character 0x30 '0'
    0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB, 0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x31 '1'
    0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x32 '2'
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x33 '3'
    0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x34 '4'
    0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x35 '5'
    0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x36 '6'
    0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x37 '7'
    0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
    // Character 0x38 '8'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x39 '9'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3A ':'
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3B ';'
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3C '<'
    0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3D '='
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3E '>'
    0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
    // Character 0x3F '?'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x40 '@'
    0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x41 'A'
    0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x42 'B'
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00,
    // Character 0x43 'C'
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x44 'D'
    0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00,
    // Character 0x45 'E'
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x46 'F'
    0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Character 0x47 'G'
    0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00,
    // Character 0x48 'H'
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x49 'I'
    0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4A 'J'
    0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4B 'K'
    0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4C 'L'
    0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4D 'M'
    0x00, 0x00, 0xC3, 0xE7, 0xFF, 0xFF, 0xDB, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4E 'N'
    0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x4F 'O'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x50 'P'
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Character 0x51 'Q'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00,
    // Character 0x52 'R'
    0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x53 'S'
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x54 'T'
    0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x55 'U'
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x56 'V'
    0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x57 'W'
    0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // Character 0x58 'X'
    0x00, 0x00, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x66, 0xC3, 0xC3, 0x00, 0x00, 0x00, 0x00,
    // Character 0x59 'Y'
    0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5A 'Z'
    0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5B '['
    0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5C '\'
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5D ']'
    0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5E '^'
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x5F '_'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
    // Character 0x60 '`'
    0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x61 'a'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // Character 0x62 'b'
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x63 'c'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x64 'd'
    0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // Character 0x65 'e'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x66 'f'
    0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Character 0x67 'g'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
    // Character 0x68 'h'
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x69 'i'
    0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x6A 'j'
    0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x6B 'k'
    0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
    // Character 0x6C 'l'
    0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x6D 'm'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00, 0x00,
    // Character 0x6E 'n'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
    // Character 0x6F 'o'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x70 'p'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
    // Character 0x71 'q'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00,
    // Character 0x72 'r'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00,
    // Character 0x73 's'
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x74 't'
    0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00,
    // Character 0x75 'u'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
    // Character 0x76 'v'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x77 'w'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xDB, 0xDB, 0xFF, 0x66, 0x00, 0x00, 0x00, 0x00,
    // Character 0x78 'x'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0xC3, 0x00, 0x00, 0x00, 0x00,
    // Character 0x79 'y'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00,
    // Character 0x7A 'z'
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
    // Character 0x7B '{'
    0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x7C '|'
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
    // Character 0x7D '}'
    0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
    // Character 0x7E '~'
    0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x7F (DEL)
    0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Characters 0x80-0xFF (extended ASCII - filled with blank/placeholder)
    // For now, we use empty glyphs. A full implementation would include box-drawing, etc.
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x81
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x82
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x83
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x84
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x85
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x86
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x87
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x88
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x89
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x90
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x91
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x92
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x93
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x94
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x95
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x96
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x97
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x98
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x99
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xED
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFF
];

/// Draw a character at pixel position (x, y)
pub fn draw_char(fb: &mut Ramfb, x: u32, y: u32, c: u8, fg: u32, bg: u32) {
    let glyph_offset = (c as usize) * FONT_HEIGHT as usize;
    let glyph = &FONT_DATA[glyph_offset..glyph_offset + FONT_HEIGHT as usize];

    for row in 0..FONT_HEIGHT {
        let bits = glyph[row as usize];
        for col in 0..FONT_WIDTH {
            let pixel = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            fb.put_pixel(x + col, y + row, pixel);
        }
    }

    // Memory barrier to ensure all writes are visible
    unsafe {
        core::arch::asm!("dsb sy", options(nostack, preserves_flags));
    }
}

/// Draw a character on VirtIO-GPU framebuffer (no flush - caller must flush)
pub fn draw_char_gpu(gpu: &mut VirtioGpu, x: u32, y: u32, c: u8, fg: u32, bg: u32) {
    let glyph_offset = (c as usize) * FONT_HEIGHT as usize;
    let glyph = &FONT_DATA[glyph_offset..glyph_offset + FONT_HEIGHT as usize];

    for row in 0..FONT_HEIGHT {
        let bits = glyph[row as usize];
        for col in 0..FONT_WIDTH {
            let pixel = if (bits >> (7 - col)) & 1 != 0 { fg } else { bg };
            gpu.put_pixel(x + col, y + row, pixel);
        }
    }
}

/// Text console state
/// Escape sequence parser state
#[derive(Clone, Copy, PartialEq)]
enum EscState {
    Normal,   // Normal character output
    Escape,   // Saw ESC (0x1B)
    Csi,      // Saw ESC [ (Control Sequence Introducer)
}

/// Standard ANSI colors (0-7)
const ANSI_COLORS: [u32; 8] = [
    0x000000, // 0: Black
    0xCC0000, // 1: Red
    0x00CC00, // 2: Green
    0xCCCC00, // 3: Yellow
    0x0000CC, // 4: Blue
    0xCC00CC, // 5: Magenta
    0x00CCCC, // 6: Cyan
    0xCCCCCC, // 7: White
];

/// Bright ANSI colors (8-15)
const ANSI_BRIGHT_COLORS: [u32; 8] = [
    0x666666, // 8: Bright Black (Gray)
    0xFF0000, // 9: Bright Red
    0x00FF00, // 10: Bright Green
    0xFFFF00, // 11: Bright Yellow
    0x0000FF, // 12: Bright Blue
    0xFF00FF, // 13: Bright Magenta
    0x00FFFF, // 14: Bright Cyan
    0xFFFFFF, // 15: Bright White
];

pub struct TextConsole {
    cursor_x: u32,      // Column (0-based)
    cursor_y: u32,      // Row (0-based)
    fg_color: u32,      // Current foreground color
    bg_color: u32,      // Current background color
    default_fg: u32,    // Default foreground color
    default_bg: u32,    // Default background color
    cols: u32,          // Number of columns
    rows: u32,          // Number of rows
    bold: bool,         // Bold/bright mode
    // Escape sequence state
    esc_state: EscState,
    esc_params: [u32; 8],   // CSI parameters (expanded for SGR)
    esc_param_idx: usize,   // Current parameter index
}

impl TextConsole {
    /// Create a new text console for the given framebuffer dimensions
    pub fn new(fb_width: u32, fb_height: u32, fg: u32, bg: u32) -> Self {
        Self {
            cursor_x: 0,
            cursor_y: 0,
            fg_color: fg,
            bg_color: bg,
            default_fg: fg,
            default_bg: bg,
            cols: fb_width / FONT_WIDTH,
            rows: fb_height / FONT_HEIGHT,
            bold: false,
            esc_state: EscState::Normal,
            esc_params: [0; 8],
            esc_param_idx: 0,
        }
    }

    /// Get number of columns
    pub fn cols(&self) -> u32 {
        self.cols
    }

    /// Get number of rows
    pub fn rows(&self) -> u32 {
        self.rows
    }

    /// Set cursor position
    pub fn set_cursor(&mut self, x: u32, y: u32) {
        if x < self.cols {
            self.cursor_x = x;
        }
        if y < self.rows {
            self.cursor_y = y;
        }
    }

    /// Get cursor position
    pub fn cursor(&self) -> (u32, u32) {
        (self.cursor_x, self.cursor_y)
    }

    /// Set colors
    pub fn set_colors(&mut self, fg: u32, bg: u32) {
        self.fg_color = fg;
        self.bg_color = bg;
    }

    /// Print a character at the current cursor position
    pub fn put_char(&mut self, fb: &mut Ramfb, c: u8) {
        // Handle escape sequence state machine
        match self.esc_state {
            EscState::Normal => {
                match c {
                    0x1B => {
                        // ESC - start escape sequence
                        self.esc_state = EscState::Escape;
                    }
                    b'\n' => {
                        self.cursor_x = 0;
                        self.cursor_y += 1;
                        if self.cursor_y >= self.rows {
                            self.scroll(fb);
                            self.cursor_y = 0;  // scroll clears screen, start at top
                        }
                    }
                    b'\r' => {
                        self.cursor_x = 0;
                    }
                    0x08 => {
                        // Backspace - move cursor left and erase character
                        if self.cursor_x > 0 {
                            self.cursor_x -= 1;
                            // Erase character at cursor position
                            let px = self.cursor_x * FONT_WIDTH;
                            let py = self.cursor_y * FONT_HEIGHT;
                            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
                        }
                    }
                    0x7F => {
                        // DEL - same as backspace for terminal
                        if self.cursor_x > 0 {
                            self.cursor_x -= 1;
                            let px = self.cursor_x * FONT_WIDTH;
                            let py = self.cursor_y * FONT_HEIGHT;
                            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
                        }
                    }
                    b'\t' => {
                        // Tab to next 8-column boundary
                        let next_tab = (self.cursor_x + 8) & !7;
                        if next_tab < self.cols {
                            self.cursor_x = next_tab;
                        } else {
                            self.cursor_x = 0;
                            self.cursor_y += 1;
                            if self.cursor_y >= self.rows {
                                self.scroll(fb);
                                self.cursor_y = 0;  // scroll clears screen, start at top
                            }
                        }
                    }
                    _ => {
                        // Regular character
                        let px = self.cursor_x * FONT_WIDTH;
                        let py = self.cursor_y * FONT_HEIGHT;
                        draw_char(fb, px, py, c, self.fg_color, self.bg_color);

                        self.cursor_x += 1;
                        if self.cursor_x >= self.cols {
                            self.cursor_x = 0;
                            self.cursor_y += 1;
                            if self.cursor_y >= self.rows {
                                self.scroll(fb);
                                self.cursor_y = 0;  // scroll clears screen, start at top
                            }
                        }
                    }
                }
            }
            EscState::Escape => {
                match c {
                    b'[' => {
                        // CSI - Control Sequence Introducer
                        self.esc_state = EscState::Csi;
                        self.esc_params = [0; 8];
                        self.esc_param_idx = 0;
                    }
                    _ => {
                        // Unknown escape, ignore and return to normal
                        self.esc_state = EscState::Normal;
                    }
                }
            }
            EscState::Csi => {
                match c {
                    b'0'..=b'9' => {
                        // Accumulate parameter digit
                        if self.esc_param_idx < 8 {
                            self.esc_params[self.esc_param_idx] =
                                self.esc_params[self.esc_param_idx] * 10 + (c - b'0') as u32;
                        }
                    }
                    b';' => {
                        // Parameter separator
                        if self.esc_param_idx < 7 {
                            self.esc_param_idx += 1;
                        }
                    }
                    b'A' => {
                        // Cursor Up
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_y = self.cursor_y.saturating_sub(n);
                        self.esc_state = EscState::Normal;
                    }
                    b'B' => {
                        // Cursor Down
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_y = (self.cursor_y + n).min(self.rows - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'C' => {
                        // Cursor Forward (Right)
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_x = (self.cursor_x + n).min(self.cols - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'D' => {
                        // Cursor Back (Left)
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_x = self.cursor_x.saturating_sub(n);
                        self.esc_state = EscState::Normal;
                    }
                    b'H' | b'f' => {
                        // Cursor Position - ESC[row;colH
                        let row = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        let col = if self.esc_params[1] == 0 { 1 } else { self.esc_params[1] };
                        self.cursor_y = (row - 1).min(self.rows - 1);
                        self.cursor_x = (col - 1).min(self.cols - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'J' => {
                        // Erase in Display
                        match self.esc_params[0] {
                            0 => {
                                // Clear from cursor to end of screen
                                self.clear_to_end(fb);
                            }
                            1 => {
                                // Clear from beginning to cursor
                                self.clear_from_start(fb);
                            }
                            2 | 3 => {
                                // Clear entire screen
                                fb.clear(self.bg_color);
                                self.cursor_x = 0;
                                self.cursor_y = 0;
                            }
                            _ => {}
                        }
                        self.esc_state = EscState::Normal;
                    }
                    b'K' => {
                        // Erase in Line
                        match self.esc_params[0] {
                            0 => {
                                // Clear from cursor to end of line
                                self.clear_line_to_end(fb);
                            }
                            1 => {
                                // Clear from beginning of line to cursor
                                self.clear_line_from_start(fb);
                            }
                            2 => {
                                // Clear entire line
                                self.clear_line(fb);
                            }
                            _ => {}
                        }
                        self.esc_state = EscState::Normal;
                    }
                    b'm' => {
                        // SGR - Select Graphic Rendition (colors/attributes)
                        self.handle_sgr();
                        self.esc_state = EscState::Normal;
                    }
                    0x40..=0x7E => {
                        // Any other final byte - end sequence
                        self.esc_state = EscState::Normal;
                    }
                    _ => {
                        // Continue accumulating (intermediate bytes, etc.)
                    }
                }
            }
        }
    }

    /// Clear from cursor to end of screen
    fn clear_to_end(&self, fb: &mut Ramfb) {
        // Clear rest of current line
        for x in self.cursor_x..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
        }
        // Clear remaining lines
        for y in (self.cursor_y + 1)..self.rows {
            for x in 0..self.cols {
                let px = x * FONT_WIDTH;
                let py = y * FONT_HEIGHT;
                draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
            }
        }
    }

    /// Clear from beginning of screen to cursor
    fn clear_from_start(&self, fb: &mut Ramfb) {
        // Clear lines before current
        for y in 0..self.cursor_y {
            for x in 0..self.cols {
                let px = x * FONT_WIDTH;
                let py = y * FONT_HEIGHT;
                draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
            }
        }
        // Clear current line up to cursor
        for x in 0..=self.cursor_x {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
        }
    }

    /// Clear from cursor to end of line
    fn clear_line_to_end(&self, fb: &mut Ramfb) {
        for x in self.cursor_x..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
        }
    }

    /// Clear from beginning of line to cursor
    fn clear_line_from_start(&self, fb: &mut Ramfb) {
        for x in 0..=self.cursor_x {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
        }
    }

    /// Clear entire line
    fn clear_line(&self, fb: &mut Ramfb) {
        for x in 0..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char(fb, px, py, b' ', self.fg_color, self.bg_color);
        }
    }

    /// Handle SGR (Select Graphic Rendition) escape sequence for colors
    fn handle_sgr(&mut self) {
        let count = self.esc_param_idx + 1;
        for i in 0..count {
            let param = self.esc_params[i];
            match param {
                0 => {
                    // Reset
                    self.fg_color = self.default_fg;
                    self.bg_color = self.default_bg;
                    self.bold = false;
                }
                1 => self.bold = true,
                22 => self.bold = false,
                30..=37 => {
                    let idx = (param - 30) as usize;
                    self.fg_color = if self.bold { ANSI_BRIGHT_COLORS[idx] } else { ANSI_COLORS[idx] };
                }
                39 => self.fg_color = self.default_fg,
                40..=47 => {
                    let idx = (param - 40) as usize;
                    self.bg_color = ANSI_COLORS[idx];
                }
                49 => self.bg_color = self.default_bg,
                90..=97 => {
                    let idx = (param - 90) as usize;
                    self.fg_color = ANSI_BRIGHT_COLORS[idx];
                }
                100..=107 => {
                    let idx = (param - 100) as usize;
                    self.bg_color = ANSI_BRIGHT_COLORS[idx];
                }
                _ => {}
            }
        }
    }

    /// Print a string
    pub fn print(&mut self, fb: &mut Ramfb, s: &[u8]) {
        for &c in s {
            self.put_char(fb, c);
        }
    }

    /// Scroll the screen up by one line
    /// Note: Full-screen scroll is extremely slow on uncached framebuffer (ramfb).
    /// Instead of scrolling, we just wrap around to the top of the screen.
    /// For proper scrolling, consider using virtio-gpu which uses DMA.
    pub fn scroll(&self, fb: &mut Ramfb) {
        // Clear the screen and reset cursor to top-left
        fb.clear(self.bg_color);
        // Note: cursor_y will be set to 0 by the caller after this returns
        return;

        let framebuffer = fb.framebuffer();
        let stride_pixels = fb.stride() / 4;
        let line_height = FONT_HEIGHT as usize;
        let fb_height = fb.height() as usize;

        unsafe {
            // Copy lines up
            for y in 0..(fb_height - line_height) {
                let src_offset = (y + line_height) * stride_pixels as usize;
                let dst_offset = y * stride_pixels as usize;
                for x in 0..stride_pixels as usize {
                    let pixel = framebuffer.add(src_offset + x).read_volatile();
                    framebuffer.add(dst_offset + x).write_volatile(pixel);
                }
            }

            // Clear the last line
            let last_line_start = (fb_height - line_height) * stride_pixels as usize;
            for y in 0..line_height {
                for x in 0..stride_pixels as usize {
                    framebuffer.add(last_line_start + y * stride_pixels as usize + x)
                        .write_volatile(self.bg_color);
                }
            }
        }
    }

    // ========== VirtIO-GPU specific methods ==========

    /// Print a character at the current cursor position (GPU version)
    pub fn put_char_gpu(&mut self, gpu: &mut VirtioGpu, c: u8) {
        // Handle escape sequence state machine
        match self.esc_state {
            EscState::Normal => {
                match c {
                    0x1B => {
                        // ESC - start escape sequence
                        self.esc_state = EscState::Escape;
                    }
                    b'\n' => {
                        self.cursor_x = 0;
                        self.cursor_y += 1;
                        if self.cursor_y >= self.rows {
                            self.scroll_gpu(gpu);
                            self.cursor_y = 0;  // scroll clears screen, start at top
                        }
                    }
                    b'\r' => {
                        self.cursor_x = 0;
                    }
                    0x08 => {
                        // Backspace
                        if self.cursor_x > 0 {
                            self.cursor_x -= 1;
                            let px = self.cursor_x * FONT_WIDTH;
                            let py = self.cursor_y * FONT_HEIGHT;
                            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
                            gpu.flush(px, py, FONT_WIDTH, FONT_HEIGHT);
                        }
                    }
                    0x7F => {
                        // DEL
                        if self.cursor_x > 0 {
                            self.cursor_x -= 1;
                            let px = self.cursor_x * FONT_WIDTH;
                            let py = self.cursor_y * FONT_HEIGHT;
                            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
                            gpu.flush(px, py, FONT_WIDTH, FONT_HEIGHT);
                        }
                    }
                    b'\t' => {
                        let next_tab = (self.cursor_x + 8) & !7;
                        if next_tab < self.cols {
                            self.cursor_x = next_tab;
                        } else {
                            self.cursor_x = 0;
                            self.cursor_y += 1;
                            if self.cursor_y >= self.rows {
                                self.scroll_gpu(gpu);
                                self.cursor_y = 0;  // scroll clears screen, start at top
                            }
                        }
                    }
                    _ => {
                        // Regular character
                        let px = self.cursor_x * FONT_WIDTH;
                        let py = self.cursor_y * FONT_HEIGHT;
                        draw_char_gpu(gpu, px, py, c, self.fg_color, self.bg_color);
                        gpu.flush(px, py, FONT_WIDTH, FONT_HEIGHT);

                        self.cursor_x += 1;
                        if self.cursor_x >= self.cols {
                            self.cursor_x = 0;
                            self.cursor_y += 1;
                            if self.cursor_y >= self.rows {
                                self.scroll_gpu(gpu);
                                self.cursor_y = 0;  // scroll clears screen, start at top
                            }
                        }
                    }
                }
            }
            EscState::Escape => {
                match c {
                    b'[' => {
                        self.esc_state = EscState::Csi;
                        self.esc_params = [0; 8];
                        self.esc_param_idx = 0;
                    }
                    _ => {
                        self.esc_state = EscState::Normal;
                    }
                }
            }
            EscState::Csi => {
                match c {
                    b'0'..=b'9' => {
                        if self.esc_param_idx < 8 {
                            self.esc_params[self.esc_param_idx] =
                                self.esc_params[self.esc_param_idx] * 10 + (c - b'0') as u32;
                        }
                    }
                    b';' => {
                        if self.esc_param_idx < 7 {
                            self.esc_param_idx += 1;
                        }
                    }
                    b'A' => {
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_y = self.cursor_y.saturating_sub(n);
                        self.esc_state = EscState::Normal;
                    }
                    b'B' => {
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_y = (self.cursor_y + n).min(self.rows - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'C' => {
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_x = (self.cursor_x + n).min(self.cols - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'D' => {
                        let n = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        self.cursor_x = self.cursor_x.saturating_sub(n);
                        self.esc_state = EscState::Normal;
                    }
                    b'H' | b'f' => {
                        let row = if self.esc_params[0] == 0 { 1 } else { self.esc_params[0] };
                        let col = if self.esc_params[1] == 0 { 1 } else { self.esc_params[1] };
                        self.cursor_y = (row - 1).min(self.rows - 1);
                        self.cursor_x = (col - 1).min(self.cols - 1);
                        self.esc_state = EscState::Normal;
                    }
                    b'J' => {
                        match self.esc_params[0] {
                            0 => self.clear_to_end_gpu(gpu),
                            1 => self.clear_from_start_gpu(gpu),
                            2 | 3 => {
                                gpu.clear(self.bg_color);
                                self.cursor_x = 0;
                                self.cursor_y = 0;
                            }
                            _ => {}
                        }
                        self.esc_state = EscState::Normal;
                    }
                    b'K' => {
                        match self.esc_params[0] {
                            0 => self.clear_line_to_end_gpu(gpu),
                            1 => self.clear_line_from_start_gpu(gpu),
                            2 => self.clear_line_gpu(gpu),
                            _ => {}
                        }
                        self.esc_state = EscState::Normal;
                    }
                    b'm' => {
                        self.handle_sgr();
                        self.esc_state = EscState::Normal;
                    }
                    0x40..=0x7E => {
                        self.esc_state = EscState::Normal;
                    }
                    _ => {}
                }
            }
        }
    }

    /// Clear from cursor to end of screen (GPU)
    fn clear_to_end_gpu(&self, gpu: &mut VirtioGpu) {
        for x in self.cursor_x..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
        }
        for y in (self.cursor_y + 1)..self.rows {
            for x in 0..self.cols {
                let px = x * FONT_WIDTH;
                let py = y * FONT_HEIGHT;
                draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
            }
        }
        gpu.flush(0, self.cursor_y * FONT_HEIGHT, gpu.width, gpu.height - self.cursor_y * FONT_HEIGHT);
    }

    /// Clear from beginning of screen to cursor (GPU)
    fn clear_from_start_gpu(&self, gpu: &mut VirtioGpu) {
        for y in 0..self.cursor_y {
            for x in 0..self.cols {
                let px = x * FONT_WIDTH;
                let py = y * FONT_HEIGHT;
                draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
            }
        }
        for x in 0..=self.cursor_x {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
        }
        gpu.flush(0, 0, gpu.width, (self.cursor_y + 1) * FONT_HEIGHT);
    }

    /// Clear from cursor to end of line (GPU)
    fn clear_line_to_end_gpu(&self, gpu: &mut VirtioGpu) {
        for x in self.cursor_x..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
        }
        gpu.flush(self.cursor_x * FONT_WIDTH, self.cursor_y * FONT_HEIGHT,
                  gpu.width - self.cursor_x * FONT_WIDTH, FONT_HEIGHT);
    }

    /// Clear from beginning of line to cursor (GPU)
    fn clear_line_from_start_gpu(&self, gpu: &mut VirtioGpu) {
        for x in 0..=self.cursor_x {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
        }
        gpu.flush(0, self.cursor_y * FONT_HEIGHT, (self.cursor_x + 1) * FONT_WIDTH, FONT_HEIGHT);
    }

    /// Clear entire line (GPU)
    fn clear_line_gpu(&self, gpu: &mut VirtioGpu) {
        for x in 0..self.cols {
            let px = x * FONT_WIDTH;
            let py = self.cursor_y * FONT_HEIGHT;
            draw_char_gpu(gpu, px, py, b' ', self.fg_color, self.bg_color);
        }
        gpu.flush(0, self.cursor_y * FONT_HEIGHT, gpu.width, FONT_HEIGHT);
    }

    /// Print a string (GPU version)
    pub fn print_gpu(&mut self, gpu: &mut VirtioGpu, s: &[u8]) {
        for &c in s {
            self.put_char_gpu(gpu, c);
        }
    }

    /// Scroll the screen up by one line (GPU version)
    /// Note: Full-screen scroll is slow even with virtio-gpu due to pixel-by-pixel copy.
    /// Instead of scrolling, we clear the screen and start from top.
    pub fn scroll_gpu(&self, gpu: &mut VirtioGpu) {
        use crate::virtio_gpu::{FB_WIDTH, FB_HEIGHT};

        // Clear the screen and reset cursor to top-left
        gpu.clear(self.bg_color);
        gpu.flush(0, 0, FB_WIDTH, FB_HEIGHT);
        return;

        // Original slow scroll code left for reference:
        #[allow(unreachable_code)]
        {
            use crate::virtio_gpu::FB_STRIDE;
            let framebuffer = gpu.framebuffer();
            let stride_pixels = (FB_STRIDE / 4) as usize;
            let line_height = FONT_HEIGHT as usize;
            let fb_height = FB_HEIGHT as usize;

            unsafe {
                // Copy lines up
                for y in 0..(fb_height - line_height) {
                    let src_offset = (y + line_height) * stride_pixels;
                    let dst_offset = y * stride_pixels;
                    for x in 0..stride_pixels {
                        let ptr = framebuffer as *mut u32;
                        let pixel = *ptr.add(src_offset + x);
                        *ptr.add(dst_offset + x) = pixel;
                    }
                }

                // Clear the last line
                let last_line_start = (fb_height - line_height) * stride_pixels;
                for y in 0..line_height {
                    for x in 0..stride_pixels {
                        let ptr = framebuffer as *mut u32;
                        *ptr.add(last_line_start + y * stride_pixels + x) = self.bg_color;
                    }
                }
            }

            // Flush entire screen after scroll
            gpu.flush(0, 0, FB_WIDTH, FB_HEIGHT);
        }
    }
}
