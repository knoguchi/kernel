# 2026-01-28: AArch64 Virtual Memory / MMU Implementation

## Overview

Implemented MMU (Memory Management Unit) with identity mapping for the Kenix microkernel running on QEMU virt (Cortex-A72). Identity mapping means virtual addresses equal physical addresses, which is the simplest starting point for enabling paging.

## Architecture Decisions

### TTBR0 Only (for now)
- Using only TTBR0_EL1 for translation
- Kernel runs at low addresses (0x40000000+)
- TTBR1 can be added later for userspace (high addresses)

### 2-Level Page Tables with 2MB Blocks
- 4KB granule size (standard for AArch64)
- L1 entries: each covers 1GB, points to L2 table
- L2 entries: each covers 2MB block (no L3 needed)
- Total: 3 page tables = 12KB memory

### 39-bit Virtual Address Space
- T0SZ = 25 in TCR_EL1 (64 - 25 = 39 bits)
- Translation starts at Level 1 (not Level 0)
- Sufficient for 512GB address space

## Memory Map

```
Virtual = Physical       Size    Type              Purpose
────────────────────────────────────────────────────────────
0x0800_0000              2MB     Device-nGnRnE     GIC (interrupt controller)
0x0900_0000              2MB     Device-nGnRnE     PL011 UART
0x4000_0000 - 0x8000_0000  1GB   Normal WB         RAM (kernel + free memory)
```

Page table structure:
```
L1[0] → L2_DEVICE  (covers 0x00000000 - 0x40000000)
        └─ entry[64]: GIC  at 0x08000000 (Device)
        └─ entry[72]: UART at 0x09000000 (Device)

L1[1] → L2_RAM     (covers 0x40000000 - 0x80000000)
        └─ entries[0-511]: 512 x 2MB blocks (Normal cacheable)
```

## Register Configuration

### MAIR_EL1 (Memory Attribute Indirection Register)
```
Attr0 = 0x00  → Device-nGnRnE (non-Gathering, non-Reordering, no Early write ack)
Attr1 = 0xFF  → Normal Write-Back cacheable (Inner/Outer Write-Back, Read/Write Allocate)
```

### TCR_EL1 (Translation Control Register)
```
T0SZ  = 25      → 39-bit VA for TTBR0
TG0   = 0b00    → 4KB granule
IRGN0 = 0b01    → Inner Write-Back cacheable
ORGN0 = 0b01    → Outer Write-Back cacheable
SH0   = 0b11    → Inner Shareable
EPD1  = 1       → Disable TTBR1 walks
IPS   = 0b010   → 40-bit PA (1TB physical)
```

### SCTLR_EL1 (System Control Register)
```
M = 1  → Enable MMU
C = 1  → Enable data cache
I = 1  → Enable instruction cache
```

## Page Table Entry Format

For 2MB block descriptors at L2:
```
[63:54] Upper attributes (UXN, PXN, etc.)
[53:48] Reserved
[47:21] Output address (2MB aligned)
[20:12] Reserved (SBZ for blocks)
[11]    nG (not Global)
[10]    AF (Access Flag) - must be 1
[9:8]   SH (Shareability)
[7:6]   AP (Access Permissions)
[5]     NS (Non-secure)
[4:2]   AttrIndx (MAIR index)
[1]     Type: 0=block, 1=table
[0]     Valid bit
```

## Enable Sequence

1. Allocate 3 pages from frame allocator (L1, L2_device, L2_ram)
2. Zero all tables using volatile writes
3. Fill L2_device: entries for GIC and UART as Device memory
4. Fill L2_ram: 512 entries for 1GB RAM as Normal memory
5. Fill L1: entry[0] → L2_device, entry[1] → L2_ram
6. `dsb ishst` - ensure page table writes complete
7. Write MAIR_EL1, TCR_EL1, TTBR0_EL1
8. `isb` - instruction barrier
9. `tlbi vmalle1is` - invalidate TLB
10. `dsb ish`, `isb` - barriers
11. Read SCTLR_EL1, set M|C|I bits, write back
12. `isb` - final instruction barrier

## Files Added/Modified

### New: `kernel/src/mm/paging.rs`
- `PageTableEntry` - 64-bit entry with constructors for block/table entries
- `PageTable` - 512-entry array, 4KB aligned
- `l1_index()`, `l2_index()` - VA to index extractors
- Memory attribute constants

### New: `kernel/src/mm/mmu.rs`
- `MAIR_VALUE`, `TCR_VALUE` - register configuration constants
- `init_and_enable()` - main entry point
- System register access functions (mrs/msr wrappers)

### Modified: `kernel/src/mm/mod.rs`
- Added `mod paging` and `mod mmu`
- Exported `enable_mmu()` function

### Modified: `kernel/src/main.rs`
- Calls `mm::enable_mmu()` after frame allocator init
- Prints confirmation message

## Verification

```
Enabling MMU...
  L1 table at: 0x400a0000
  L2 device table at: 0x400a1000
  L2 RAM table at: 0x400a2000
MMU enabled - identity mapping active
  UART: Device-nGnRnE
  RAM: Normal Write-Back cacheable
```

- UART output continues after enable → device mapping works
- Kernel doesn't crash → code/RAM mapping works

## Lessons Learned

1. **T0SZ matters**: Initially used T0SZ=16 (48-bit VA, 4-level), but only set up 2 levels. Changed to T0SZ=25 (39-bit VA, starts at L1) to match our 2-level setup.

2. **Volatile writes required**: Page table writes must use volatile operations to ensure they reach memory before MMU enable. Regular writes might be optimized away or reordered.

3. **Barrier sequence critical**: The exact sequence of DSB/ISB/TLBI instructions matters. Missing barriers cause silent failures or crashes.

## Future Work

- Add TTBR1 for userspace (higher-half kernel)
- Implement dynamic page mapping/unmapping
- ~~Add page fault handler~~ Done (see below)
- Support 4KB pages for fine-grained mapping

---

# 2026-01-28: AArch64 Exception Handling Implementation

## Overview

Implemented exception vector table and handlers for CPU exceptions, interrupts, and syscalls at EL1. This enables the kernel to catch faults (like null pointer dereferences), handle interrupts (future), and process system calls from userspace.

## AArch64 Exception Levels

AArch64 has 4 exception levels (EL0-EL3), each with increasing privilege:

```
EL3  Secure Monitor     (ARM TrustZone, firmware)
EL2  Hypervisor         (virtual machine monitor)
EL1  OS Kernel          ← Kenix runs here
EL0  User Application   (unprivileged)
```

**Key points:**
- Higher EL = more privilege
- Exceptions always go to same or higher EL, never lower
- Each EL has its own stack pointer (SP_EL0, SP_EL1, etc.)
- System registers are suffixed with EL level (e.g., `VBAR_EL1`, `SPSR_EL1`)

## How Exceptions Work

When a CPU exception occurs:

1. **Hardware saves state:**
   - `ELR_ELx` ← PC (return address)
   - `SPSR_ELx` ← PSTATE (saved processor status)
   - `ESR_ELx` ← Exception Syndrome (cause)
   - `FAR_ELx` ← Fault Address (for memory faults)

2. **Hardware jumps to vector:**
   - PC ← `VBAR_ELx + offset` (based on exception type and source)
   - PSTATE updated (interrupts masked, etc.)

3. **Software handler runs:**
   - Save remaining registers (x0-x30, sp)
   - Process exception
   - Restore registers
   - `eret` instruction returns (restores PC and PSTATE)

## Exception Vector Table Structure

The table is 2KB aligned (`VBAR_EL1` must be 0x800-aligned) with 16 entries organized as 4 groups × 4 types:

```
Offset    Exception Type    Source EL / Stack
──────────────────────────────────────────────────────────────
0x000     Synchronous       Current EL, SP_EL0    (unused)
0x080     IRQ               Current EL, SP_EL0    (unused)
0x100     FIQ               Current EL, SP_EL0    (unused)
0x180     SError            Current EL, SP_EL0    (unused)

0x200     Synchronous       Current EL, SP_ELx    ← Kernel faults
0x280     IRQ               Current EL, SP_ELx    ← Kernel IRQ
0x300     FIQ               Current EL, SP_ELx    ← Kernel FIQ
0x380     SError            Current EL, SP_ELx    ← Kernel SError

0x400     Synchronous       Lower EL, AArch64     ← User syscall/fault
0x480     IRQ               Lower EL, AArch64     ← User IRQ
0x500     FIQ               Lower EL, AArch64     ← User FIQ
0x580     SError            Lower EL, AArch64     ← User SError

0x600     Synchronous       Lower EL, AArch32     (unused)
0x680     IRQ               Lower EL, AArch32     (unused)
0x700     FIQ               Lower EL, AArch32     (unused)
0x780     SError            Lower EL, AArch32     (unused)
```

Each entry is 128 bytes (0x80) - enough for a branch or small stub.

**Exception Types:**
- **Synchronous**: CPU-generated, predictable (syscalls, faults, traps)
- **IRQ**: Normal hardware interrupt
- **FIQ**: Fast interrupt (higher priority)
- **SError**: System Error (async, usually fatal - ECC errors, bus faults)

## How MMU Triggers Exceptions

When MMU is enabled and code accesses an invalid address:

1. **CPU performs address translation:**
   - VA → L1 lookup → L2 lookup → PA (or fault)

2. **Translation fault if:**
   - Page table entry is invalid (bit 0 = 0)
   - No mapping exists for the address

3. **Data Abort exception raised:**
   - `ESR_EL1.EC` = 0x25 (Data Abort from current EL)
   - `ESR_EL1.DFSC` = fault status code (e.g., 0x06 = translation fault level 2)
   - `FAR_EL1` = faulting virtual address
   - CPU jumps to `VBAR_EL1 + 0x200` (sync exception, current EL)

**Example: Null pointer dereference**
```rust
unsafe { core::ptr::read_volatile(0 as *const u8); }
```
Results in:
```
ESR_EL1:  0x96000006
          ││    └─── DFSC = 0x06 (translation fault, level 2)
          │└─────── ISS (Instruction Specific Syndrome)
          └──────── EC = 0x25 (Data Abort, current EL)
FAR_EL1:  0x0000000000000000
```

## Exception Syndrome Register (ESR_EL1)

```
[31:26]  EC    Exception Class (type of exception)
[25]     IL    Instruction Length (0=16-bit, 1=32-bit)
[24:0]   ISS   Instruction Specific Syndrome (varies by EC)
```

**Common EC values:**
| EC | Name | Description |
|----|------|-------------|
| 0x00 | Unknown | Unknown reason |
| 0x15 | SVC64 | Supervisor Call from AArch64 (syscall) |
| 0x20 | IABT_LOW | Instruction Abort from lower EL |
| 0x21 | IABT_CUR | Instruction Abort from current EL |
| 0x24 | DABT_LOW | Data Abort from lower EL |
| 0x25 | DABT_CUR | Data Abort from current EL |
| 0x2C | FP | Floating-point exception |
| 0x3C | BRK | Breakpoint instruction |

**Data Fault Status Codes (DFSC, bits [5:0] for data aborts):**
| Code | Meaning |
|------|---------|
| 0x04 | Translation fault, level 0 |
| 0x05 | Translation fault, level 1 |
| 0x06 | Translation fault, level 2 |
| 0x07 | Translation fault, level 3 |
| 0x09 | Access flag fault, level 1 |
| 0x0D | Permission fault, level 1 |
| 0x0E | Permission fault, level 2 |
| 0x0F | Permission fault, level 3 |
| 0x21 | Alignment fault |

## Context Save/Restore

Exception handlers must preserve all registers. Our stack frame (288 bytes):

```
Offset   Content              Size
─────────────────────────────────────
0x000    x0-x30 (GPRs)        248 bytes (31 × 8)
0x0F8    SP (original)        8 bytes
0x100    ELR_EL1 (return PC)  8 bytes
0x108    SPSR_EL1 (status)    8 bytes
0x110    ESR_EL1 (syndrome)   8 bytes
0x118    FAR_EL1 (fault addr) 8 bytes
─────────────────────────────────────
Total:   288 bytes (0x120, 16-byte aligned)
```

Assembly macro flow:
```asm
SAVE_CONTEXT:
    sub     sp, sp, #288        // allocate frame
    stp     x0, x1, [sp, #0x00] // save GPRs
    ...
    mrs     x0, elr_el1         // save system registers
    mrs     x1, spsr_el1
    stp     x0, x1, [sp, #0x100]
    mrs     x0, esr_el1
    mrs     x1, far_el1
    stp     x0, x1, [sp, #0x110]

RESTORE_CONTEXT:
    ldp     x0, x1, [sp, #0x100]
    msr     elr_el1, x0         // restore return address
    msr     spsr_el1, x1        // restore status
    ldp     x0, x1, [sp, #0x00] // restore GPRs
    ...
    add     sp, sp, #288        // deallocate frame
    eret                        // return from exception
```

## Handler Behavior

| Exception | Source | Handler Action |
|-----------|--------|----------------|
| EL1 Sync | Kernel fault | Panic with debug info |
| EL1 IRQ | Hardware interrupt | Panic "not implemented" (needs GIC) |
| EL1 SError | System error | Panic with error info |
| EL0 Sync (SVC) | User syscall | Return -ENOSYS (stub) |
| EL0 Sync (fault) | User fault | Print error, halt (future: SIGSEGV) |
| EL0 IRQ | User interrupted | Same as EL1 IRQ |

## Files Added/Modified

### New: `kernel/src/exception/vectors.s`
- `SAVE_CONTEXT` / `RESTORE_CONTEXT` macros
- 2KB-aligned vector table with 16 entries
- Each active entry saves context, calls Rust handler, restores, `eret`

### New: `kernel/src/exception/context.rs`
- `ExceptionContext` struct matching stack frame layout
- Helper methods: `exception_class()`, `is_svc()`, `is_data_abort()`, `svc_number()`, `fault_status_code()`

### New: `kernel/src/exception/mod.rs`
- `init()` - writes `VBAR_EL1` register
- `vbar_el1()` - reads current value
- `handle_el1_sync/irq/fiq/serror()` - kernel exception handlers
- `handle_el0_sync/irq/fiq/serror()` - user exception handlers

### Modified: `kernel/linker.ld`
```ld
.vectors : ALIGN(0x800) {
    __exception_vectors_start = .;
    *(.text.vectors)
}
```

### Modified: `kernel/build.rs`
- Compiles `vectors.s` alongside `boot.s`

### Modified: `kernel/src/main.rs`
- `mod exception;`
- Calls `exception::init()` after MMU enable

## Verification

Normal boot:
```
Setting up exception vectors...
  VBAR_EL1: 0x0000000040084800
Exception handling ready!
```

Null pointer test:
```
Testing exception handler with null pointer access...

!!! KERNEL EXCEPTION !!!
KERNEL DATA ABORT!
Faulting address: 0x0000000000000000
  Exception Class: Data abort (current EL) (0x25)
  ESR_EL1:  0x0000000096000006
  ELR_EL1:  0x0000000040083d7c
  SPSR_EL1: 0x00000000600003c5
  FAR_EL1:  0x0000000000000000
  SP:       0x00000000400a0f80
  Fault: Translation fault, level 2 (read)
```

## Future Work

- ~~Implement GIC driver for IRQ handling~~ Done (see below)
- ~~Add syscall dispatch table~~ Done (see below)
- User process signal delivery (SIGSEGV, etc.)
- Nested exception handling (currently handlers just panic/halt)

---

# 2026-01-28: Preemptive Round-Robin Scheduler

## Overview

Implemented a preemptive scheduler that uses timer interrupts to switch between kernel tasks. This required integrating several components: GICv2 interrupt controller, ARM Generic Timer, and a context switching mechanism that works with the existing exception handling infrastructure.

## Architecture

### Scheduling Strategy

- **Round-robin** with time slices (1 tick = 10ms default)
- **Preemptive**: Timer IRQ triggers reschedule when time slice expires
- **Cooperative yield** also supported (for future use)
- **Single-core only** (SMP extension planned)

### Task Structure

```rust
pub struct Task {
    pub id: TaskId,
    pub state: TaskState,          // Free, Ready, Running, Blocked, Terminated
    pub kernel_stack_base: PhysAddr,
    pub kernel_stack_top: usize,   // Saved SP pointing to ExceptionContext
    pub page_table: PhysAddr,      // TTBR0_EL1 (0 = kernel table)
    pub entry_point: usize,
    pub time_slice: u32,
    pub next: Option<TaskId>,      // Ready queue linked list
}
```

### Context Switch Flow

The key insight is that we reuse the exception handling infrastructure for context switching:

```
1. Timer IRQ fires while task A runs
2. Vector entry → SAVE_CONTEXT (saves A's registers to A's stack)
3. handle_el1_irq() called with ctx pointing to saved context
4. tick() returns true (time slice expired, ready queue not empty)
5. context_switch():
   - Save A's SP (points to its ExceptionContext)
   - Enqueue A to ready queue
   - Dequeue B from ready queue
   - Call switch_context_and_restore(B's SP)
6. switch_context_and_restore:
   - Set SP = B's saved context
   - RESTORE_CONTEXT (loads B's registers)
   - ERET (returns to B's saved ELR with B's SPSR)
```

### New Task Setup

When creating a task, we set up a **fake ExceptionContext** on its stack:

```rust
// At stack_top - 288 bytes:
(*ctx).elr = entry_point as u64;  // Where ERET will jump
(*ctx).spsr = 0x305;              // EL1h, IRQs enabled
(*ctx).sp = ctx_addr as u64;      // Initial stack pointer
// All GPRs zeroed
```

When the scheduler first switches to this task, RESTORE_CONTEXT pops this fake context and ERET jumps to the entry point.

## Key Components

### GIC Driver (`gic.rs`)

GICv2 for QEMU virt machine:

```
GICD (Distributor): 0x0800_0000
GICC (CPU Interface): 0x0801_0000
```

Key operations:
- `init()`: Enable distributor and CPU interface
- `enable_irq(30)`: Enable timer IRQ (PPI ID 30)
- `acknowledge()`: Read GICC_IAR, get IRQ number
- `end_of_interrupt(irq)`: Write GICC_EOIR, signal completion

### Timer (`timer.rs`)

ARM Generic Timer using system registers:

```
CNTFRQ_EL0:  Timer frequency (62.5 MHz on QEMU)
CNTP_CTL_EL0: Control (enable, mask)
CNTP_TVAL_EL0: Countdown value
```

- `start(interval_ms)`: Set countdown = frequency * interval / 1000, enable
- `acknowledge_and_reset()`: Re-arm timer for next tick

### Scheduler (`sched/mod.rs`)

Ready queue as linked list:
- `enqueue(id)`: Add to tail, O(1)
- `dequeue()`: Remove from head, O(1)
- `tick()`: Decrement time_slice, return true if reschedule needed

### Assembly Helper (`vectors.s`)

```asm
.global switch_context_and_restore
switch_context_and_restore:
    mov     sp, x0          // Set SP to new task's saved context
    RESTORE_CONTEXT         // Restore all registers, ERET
```

This function **never returns** - it switches stack and does ERET directly.

## Critical Bugs Fixed

### 1. Vector Table Entry Overflow

**Problem**: Each vector entry is only 128 bytes (0x80), but SAVE_CONTEXT + handler + RESTORE_CONTEXT expanded to ~200 bytes, causing entries to overflow into adjacent entries.

**Symptom**: Data abort at 0x80000000 before IRQ handler even ran.

**Fix**: Each vector entry just branches to handler code located outside the table:
```asm
.balign 0x80
    b       el1_irq_handler   // 0x280: IRQ

// ... after table ...
el1_irq_handler:
    SAVE_CONTEXT
    bl      handle_el1_irq
    RESTORE_CONTEXT
```

### 2. EOI Before Context Switch

**Problem**: `switch_context_and_restore` never returns (does ERET), so `gic::end_of_interrupt()` was never called after a context switch. GIC wouldn't deliver more interrupts.

**Symptom**: Only one timer tick, then silence.

**Fix**: Call EOI before context switch:
```rust
if irq == TIMER_IRQ {
    timer::acknowledge_and_reset();
    let needs_switch = sched::tick();
    gic::end_of_interrupt(irq);  // EOI BEFORE switch
    if needs_switch {
        context_switch(ctx);      // May not return
    }
}
```

### 3. Return Address on Wrong Stack

**Problem**: When `context_switch` changed SP and then returned via normal Rust epilogue, it tried to load the return address from the new task's stack (garbage).

**Symptom**: Instruction abort at address 0x0000000000000000.

**Fix**: Don't return from context_switch normally. Call assembly function that sets SP and does ERET directly:
```rust
// Instead of:
// asm!("mov sp, {}", new_sp);  // then return (broken!)

// Do:
switch_context_and_restore(new_sp);  // Never returns
```

## Files Added/Modified

### New Files

| File | Purpose |
|------|---------|
| `kernel/src/gic.rs` | GICv2 interrupt controller driver |
| `kernel/src/timer.rs` | ARM Generic Timer driver |
| `kernel/src/sched/mod.rs` | Scheduler core, context_switch |
| `kernel/src/sched/task.rs` | Task structure, ready queue |
| `kernel/src/syscall.rs` | Syscall dispatcher stub |

### Modified Files

| File | Changes |
|------|---------|
| `kernel/src/exception/vectors.s` | Moved handlers outside table, added `switch_context_and_restore` |
| `kernel/src/exception/mod.rs` | IRQ handler calls scheduler |
| `kernel/src/main.rs` | Init GIC, timer, scheduler; create test tasks |

## SPSR Configuration

For new tasks (start in EL1 with interrupts enabled):

```
SPSR = 0x305 = 0b0011_0000_0101

Bits:
[3:0]  M    = 0101 (EL1h - using SP_EL1)
[4]    M    = 0
[6]    F    = 0 (FIQ enabled)
[7]    I    = 0 (IRQ enabled)
[8]    A    = 1 (SError masked)
[9]    D    = 1 (Debug masked)
```

## Verification

```
Starting scheduler...
AAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAA
BBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBB
AAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAA
...
```

- Tasks A and B alternate (round-robin)
- Each runs for one time slice before preemption
- Idle task (0) runs when both yield or block

## Syscalls (Stub)

| Number | Name | Current Behavior |
|--------|------|------------------|
| 0 | SYS_YIELD | Calls `sched::yield_cpu()` |
| 1 | SYS_EXIT | Calls `sched::exit()` |
| * | Unknown | Returns -ENOSYS |

## Future Work

- ~~Per-task page tables (TTBR0 switch in context_switch)~~ Done (see below)
- Priority-based scheduling
- Blocking wait queues (for IPC, I/O)
- SMP support (per-CPU schedulers, IPIs)
- Real-time scheduling classes

---

# 2026-01-28: Userspace Support

## Overview

Implemented user/kernel privilege separation using AArch64 exception levels (EL0/EL1). Each user task now runs in its own address space with separate page tables, and communicates with the kernel through a Linux-compatible system call interface.

## Architecture Decisions

### EL0 for Userspace
Standard ARM privilege level for user applications. User code cannot access kernel memory, execute privileged instructions, or directly manipulate hardware.

### Per-task TTBR0
Each user task gets its own L1 page table installed in TTBR0_EL1. On context switch, the scheduler updates TTBR0 to point to the new task's page table, giving each task an isolated virtual address space.

### Separate Kernel Stacks
Each task has a dedicated 16KB kernel stack used during syscalls and interrupts. This prevents user stack overflow attacks from corrupting kernel state - even if user stack is exhausted, the kernel stack remains safe.

### W^X Enforcement
Memory protection follows Write XOR Execute policy:
- Code pages: Executable, read-only (non-writable)
- Data/stack pages: Read-write, non-executable

This prevents code injection attacks where an attacker writes shellcode to a buffer and jumps to it.

### Linux Syscall ABI
Following the Linux AArch64 convention for familiarity:
- `x8`: Syscall number
- `x0-x5`: Arguments
- `x0`: Return value
- `svc #0`: Trap instruction

## Memory Layout

```
Virtual Address      Size    Permissions    Purpose
────────────────────────────────────────────────────────
0x0000_0000          2MB     User RX        User code (.text)
0x0020_0000          2MB     User RW        User stack
0x4000_0000+         -       Kernel only    Kernel mappings (inherited)
```

User code starts at virtual address 0, with stack at 2MB. Kernel mappings are copied into user page tables but marked kernel-only (AP=0b00), so user code faults if it tries to access kernel memory.

## System Calls

| Number | Name      | Arguments           | Description                    |
|--------|-----------|---------------------|--------------------------------|
| 0      | SYS_YIELD | -                   | Voluntary CPU yield            |
| 64     | SYS_WRITE | fd, buf, len        | Write to stdout (fd=1) or stderr (fd=2) |
| 93     | SYS_EXIT  | status              | Terminate task                 |

Numbers 64 and 93 match Linux AArch64 for potential future compatibility.

## User Task Creation Flow

`create_user_task(entry, code_phys, stack_phys)` performs:

1. **Allocate new L1 page table** from frame allocator (4KB)
2. **Copy kernel/device mappings** from kernel's page table
   - Ensures syscalls can access kernel code and UART
3. **Map user code** at VA 0x0 with user permissions (AP=0b01, UXN=0, PXN=1)
4. **Map user stack** at VA 0x200000 with user permissions (AP=0b01, UXN=1)
5. **Allocate kernel stack** (4 pages = 16KB) for syscalls/interrupts
6. **Create fake ExceptionContext** at top of kernel stack:
   ```rust
   ctx.elr = entry_point;  // User entry address
   ctx.spsr = 0x0;         // EL0t mode - the key!
   ctx.sp = 0x200000 + 2MB - 16;  // User stack top
   ```
7. **Register task** with scheduler

The magic is `SPSR = 0`: when ERET executes, it restores PSTATE from SPSR, and `M[3:0] = 0` means EL0t (user mode with SP_EL0).

## EL0 → EL1 Transition (Syscall)

When user code executes `svc #0`:

```
1. User: svc #0

2. CPU automatically:
   - Saves PC to ELR_EL1
   - Saves PSTATE to SPSR_EL1
   - Sets ESR_EL1.EC = 0x15 (SVC from AArch64)
   - Jumps to VBAR_EL1 + 0x400 (sync from lower EL)

3. Vector entry:
   - Switches to kernel stack (SP_EL1)
   - SAVE_CONTEXT macro saves all registers

4. handle_el0_sync():
   - Checks ESR.EC == 0x15 (SVC)
   - Extracts syscall number from x8
   - Calls syscall::dispatch(ctx)

5. syscall::dispatch():
   - Reads args from ctx.x0-x5
   - Executes syscall
   - Stores return value in ctx.x0

6. Vector exit:
   - RESTORE_CONTEXT loads registers (including modified x0)
   - ERET returns to user mode (restores ELR → PC, SPSR → PSTATE)
```

## Files Added/Modified

### New Files

| File | Purpose |
|------|---------|
| `kernel/src/mm/address_space.rs` | Per-task address space: create, map user pages |
| `kernel/src/syscall.rs` | Syscall dispatcher with SYS_YIELD, SYS_WRITE, SYS_EXIT |
| `user/init.s` | Test user program that prints and exits |
| `user/user.ld` | User linker script (base at 0x0) |

### Modified Files

| File | Changes |
|------|---------|
| `kernel/src/sched/mod.rs` | Added `create_user_task()`, TTBR0 switch in context_switch |
| `kernel/src/sched/task.rs` | Added `user_page_table` field, `is_user()` method |
| `kernel/src/exception/mod.rs` | EL0 handlers dispatch to syscall or print fault info |
| `kernel/src/mm/paging.rs` | Added user permission flags (AP, UXN, PXN) |
| `kernel/src/mm/mod.rs` | Exported address_space module |
| `kernel/build.rs` | Build user program, include as binary |
| `Makefile` | Added user/ directory to build |

## Key Code Snippets

### User Page Table Entry Flags

```rust
// User code: readable, executable by user, not by kernel
const USER_CODE: u64 = VALID | BLOCK | AF | INNER_SHAREABLE
    | AP_USER_RO    // AP=0b01: EL0 read-only, EL1 read-write
    | ATTR_NORMAL   // Cacheable
    | PXN;          // Privileged execute never (kernel can't exec)
    // UXN=0 (default): User can execute

// User data: readable, writable by user, not executable
const USER_DATA: u64 = VALID | BLOCK | AF | INNER_SHAREABLE
    | AP_USER_RW    // AP=0b01: EL0 read-write
    | ATTR_NORMAL
    | UXN           // User execute never
    | PXN;          // Privileged execute never
```

### SPSR for EL0 Return

```rust
// SPSR = 0 means:
// M[3:0] = 0b0000 = EL0t (EL0 using SP_EL0)
// All interrupt masks clear (DAIF = 0)
// No condition flags set
(*ctx).spsr = 0;
```

### Syscall Dispatch

```rust
pub fn dispatch(ctx: &mut ExceptionContext) {
    let syscall_num = ctx.x[8];
    let result = match syscall_num {
        SYS_YIELD => { sched::yield_cpu(); 0 }
        SYS_WRITE => sys_write(ctx.x[0], ctx.x[1], ctx.x[2]),
        SYS_EXIT => { sched::exit(ctx.x[0] as i32); 0 }
        _ => -(ENOSYS as i64),
    };
    ctx.x[0] = result as u64;
}
```

## Verification

User init program (`user/init.s`):
```asm
.global _start
_start:
    // SYS_WRITE(1, msg, len)
    mov     x0, #1              // fd = stdout
    ldr     x1, =msg            // buf
    mov     x2, #22             // len
    mov     x8, #64             // SYS_WRITE
    svc     #0

    // SYS_EXIT(0)
    mov     x0, #0              // status
    mov     x8, #93             // SYS_EXIT
    svc     #0

msg: .asciz "Hello from userland!\n"
```

Boot output:
```
Starting user init task...
  User page table at: 0x400a5000
  User code mapped: VA 0x0 -> PA 0x40100000
  User stack mapped: VA 0x200000 -> PA 0x400a6000
  Kernel stack at: 0x400a7000

Switching to user mode...
Hello from userland!
[Task 2 exited with status 0]
```

### Fault Handling Test

Attempting to access kernel memory from user mode:
```
User task attempted to read 0x40080000
  Exception Class: Data abort (lower EL) (0x24)
  ESR: 0x92000006 (translation fault, level 2)
[Task terminated due to fault]
```

## Future Work

- More syscalls (open, read, close, mmap, fork, exec)
- ELF loader for real binaries
- User heap with brk/mmap
- Inter-process communication (pipes, shared memory)
- Signal delivery (SIGSEGV, SIGKILL, etc.)
- Copy-on-write fork

---

# 2026-01-28: Microkernel IPC Implementation

## Overview

Implemented L4-style synchronous message-passing IPC as the foundation for a proper microkernel. User programs now communicate with servers via message passing instead of direct syscalls. A user-space console server handles all UART output, demonstrating the microkernel architecture where device drivers run as unprivileged servers.

## IPC Model

### Why Synchronous IPC?

- **Simpler implementation** - No message queues needed
- **Predictable latency** - Direct task-to-task transfer
- **Natural for RPC** - Client-server pattern fits microkernel services
- **L4/seL4 proven** - Battle-tested in real microkernels

### Message Structure

Messages are small (fit in registers) for fast path:

```rust
pub struct Message {
    pub tag: u64,           // Message type/opcode
    pub data: [u64; 4],     // 4 words of inline data (32 bytes)
}
```

## Syscall Interface

| Syscall | Number | Args | Description |
|---------|--------|------|-------------|
| `sys_send` | 1 | x0=dest_tid, x1=tag, x2-x5=data | Send message, block until received |
| `sys_recv` | 2 | x0=from_tid (-1 for any) | Receive message, block until available |
| `sys_call` | 3 | x0=dest_tid, x1=tag, x2-x5=data | Send + wait for reply (RPC) |
| `sys_reply` | 4 | x0=tag, x1-x4=data | Reply to caller |

### Register Convention

- **Send**: x0=dest, x1=tag, x2-x5=data → returns 0 on success
- **Recv**: x0=from (-1=any) → returns sender_tid in x0, tag in x1, data in x2-x5
- **Call**: Like send, but blocks for reply → returns reply in x0-x4
- **Reply**: x0=tag, x1-x4=data → returns 0 on success

## Task State Machine

```
          ┌───────────┐
          │   Free    │
          └─────┬─────┘
                │ create_task()
                ▼
          ┌───────────┐      tick() / yield()
          │   Ready   │◄─────────────────────┐
          └─────┬─────┘                      │
                │ schedule()                 │
                ▼                            │
          ┌───────────┐                      │
          │  Running  │──────────────────────┘
          └─────┬─────┘
                │ sys_send/recv/call
                ▼
    ┌───────────┼───────────┐
    ▼           ▼           ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│  Send   │ │  Recv   │ │ Reply   │
│ Blocked │ │ Blocked │ │ Blocked │
└────┬────┘ └────┬────┘ └────┬────┘
     │           │           │
     └───────────┴───────────┘
                │ message delivered / reply received
                ▼
          ┌───────────┐
          │   Ready   │
          └───────────┘
```

## IPC Flow

### sys_call (Client) / sys_recv + sys_reply (Server)

```
Client (Init, Task 2)               Server (Console, Task 1)
       │                                    │
       │ sys_call(1, MSG_WRITE, data)       │
       │                                    │ sys_recv(ANY)
       │ ----[ReplyBlocked]------------     │ [RecvBlocked]
       │                                    │
       │     [message transfer]             │
       │                                    │ [woken, processes msg]
       │                                    │ uart_write(...)
       │                                    │ sys_reply(written)
       │                                    │
       │ [woken with reply]                 │ [continues to next recv]
       │ [returns from sys_call]            │
```

## Implementation Details

### IPC State in Task Structure

```rust
pub struct IpcState {
    /// Queue of tasks waiting to send to this task
    pub sender_queue_head: Option<TaskId>,
    pub sender_queue_tail: Option<TaskId>,

    /// Link for being in another task's sender queue
    pub sender_next: Option<TaskId>,

    /// Task we're waiting for a reply from (for sys_call)
    pub reply_to: Option<TaskId>,

    /// Who called us (for sys_reply to know the target)
    pub caller: Option<TaskId>,

    /// Filter for sys_recv (None = accept any)
    pub recv_from: Option<TaskId>,

    /// Pending message (when blocked)
    pub pending_msg: Message,
}
```

### Sender Queue

When a sender finds the receiver not waiting, it enqueues itself:

```rust
pub unsafe fn enqueue_sender(receiver_id: TaskId, sender_id: TaskId) {
    let receiver = &mut TASKS[receiver_id.0];
    let sender = &mut TASKS[sender_id.0];
    sender.ipc.sender_next = None;

    if let Some(tail_id) = receiver.ipc.sender_queue_tail {
        TASKS[tail_id.0].ipc.sender_next = Some(sender_id);
        receiver.ipc.sender_queue_tail = Some(sender_id);
    } else {
        receiver.ipc.sender_queue_head = Some(sender_id);
        receiver.ipc.sender_queue_tail = Some(sender_id);
    }
}
```

## Bugs Fixed

### 1. AArch64 AP Bits Wrong for User Access

**Problem**: User-mode console server got "Permission fault, level 2" when accessing UART at 0x09000018.

**Root Cause**: The `make_block_entry()` function had incorrect access permission bits:

```rust
// WRONG: AP[2:1]=00 means EL1-only, not user read-write!
if flags.user && !flags.writable {
    entry |= 0b01 << 6; // Only set for read-only
}
// writable user case: AP stays 00 = NO USER ACCESS
```

**AArch64 AP Encoding**:
| AP[2:1] | EL1 | EL0 |
|---------|-----|-----|
| 00 | R/W | None |
| 01 | R/W | R/W |
| 10 | R/O | None |
| 11 | R/O | R/O |

**Fix**:
```rust
if flags.user {
    if flags.writable {
        entry |= 0b01 << 6; // EL0/EL1 read-write
    } else {
        entry |= 0b11 << 6; // EL0/EL1 read-only
    }
}
```

### 2. Cross-Address-Space Pointer Bug

**Problem**: Init passed a pointer to its string buffer to the console server, but they have separate address spaces.

**Original Code**:
```c
// init.c
Message msg = {
    .tag = MSG_WRITE,
    .data = {(unsigned long)s, strlen(s), 0, 0}  // POINTER!
};
sys_call(CONSOLE_SERVER, &msg);

// console.c
const char *buf = (const char*)recv.msg.data[0];  // Invalid in our addr space!
```

**Fix**: Copy small strings inline (up to 24 bytes in data[1-3]):
```c
// init.c
Message msg = {
    .tag = MSG_WRITE,
    .data = {len, 0, 0, 0}  // data[0] = length
};
memcpy(&msg.data[1], s, len);  // data[1-3] = inline string

// console.c
unsigned long len = recv.msg.data[0];
const char *buf = (const char*)&recv.msg.data[1];  // Read from message
```

### 3. IPC Return Values Not Set for Blocked Tasks

**Problem**: When a task blocked on `sys_recv` was later woken, it returned to user-space with stale register values.

**Root Cause**: The context switch mechanism:
1. Task blocks, `context_switch_blocking()` saves ExceptionContext to stack
2. Other task runs, eventually wakes the blocked task
3. `switch_context_and_restore()` sets SP to blocked task's context
4. `ERET` restores registers and returns to user-space

The issue: when the IPC function "returned", it set ctx.gpr values, but the context had already been saved. The ERET restored the OLD saved values, not the ones the IPC function wrote.

**Fix**: When waking a blocked task, write return values directly to its saved ExceptionContext:

```rust
unsafe fn set_recv_return(task_id: TaskId, sender_id: TaskId, msg: &Message) {
    let task = &TASKS[task_id.0];
    let ctx = task.kernel_stack_top as *mut ExceptionContext;
    if !ctx.is_null() {
        (*ctx).gpr[0] = sender_id.0 as u64;
        (*ctx).gpr[1] = msg.tag;
        (*ctx).gpr[2] = msg.data[0];
        (*ctx).gpr[3] = msg.data[1];
        (*ctx).gpr[4] = msg.data[2];
        (*ctx).gpr[5] = msg.data[3];
    }
}

// In sys_call when waking receiver:
set_recv_return(dest, caller_id, &msg);
dest_task.state = TaskState::Ready;
sched::enqueue_task(dest);

// In sys_reply when waking caller:
set_call_return(caller_id, &reply_msg);
caller_task.state = TaskState::Ready;
sched::enqueue_task(caller_id);
```

## Console Server

User-space server that handles MSG_WRITE requests:

```c
// Console server main loop
void console_main(void) {
    uart_puts("[console] Server started\n");

    while (1) {
        RecvResult recv = sys_recv(TASK_ANY);

        if (recv.msg.tag == MSG_WRITE) {
            unsigned long len = recv.msg.data[0];
            const char *buf = (const char*)&recv.msg.data[1];
            unsigned long written = uart_write(buf, len);

            Message reply = { .tag = written };
            sys_reply(&reply);
        }
    }
}
```

The kernel maps UART MMIO (0x09000000) into the console server's address space with `PageFlags::user_device()`, allowing direct hardware access from user-mode.

## Files Added/Modified

### New Files

| File | Purpose |
|------|---------|
| `kernel/src/ipc.rs` | Core IPC: sys_send, sys_recv, sys_call, sys_reply |
| `user/ipc.h` | User-space IPC types and syscall wrappers |
| `user/console.c` | Console server with UART access |
| `user/crt0_console.s` | Console server startup code |

### Modified Files

| File | Changes |
|------|---------|
| `kernel/src/sched/task.rs` | Added Message, IpcState, new TaskState variants |
| `kernel/src/sched/mod.rs` | Added create_console_server_from_elf, context_switch_blocking |
| `kernel/src/syscall.rs` | Added SYS_SEND/RECV/CALL/REPLY handlers |
| `kernel/src/mm/address_space.rs` | Fixed AP bits, added user_device() flags |
| `kernel/src/main.rs` | Create console server before init |
| `kernel/src/user_code.s` | Embed console.elf and init.elf |
| `user/init.c` | Use IPC to print via console server |
| `Makefile` | Build console server |

## Verification

```
Starting scheduler...
[console] Server started
Hello via IPC!
Init running in EL0
IPC works!
```

- Console server starts in EL0, prints startup message via direct UART access
- Init (task 2) sends MSG_WRITE messages to console (task 1) via sys_call
- Console receives, writes to UART, replies
- Init receives replies and continues

## Future Work

- **Capabilities**: Replace TaskId with handles for access control
- **Timeouts**: Add timeout parameter to recv/call
- **Async IPC**: Add non-blocking variants with notifications
- **Large messages**: Shared memory regions for bulk transfer
- **More servers**: VFS, block device, network stack
