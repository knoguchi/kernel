# 2026-01-28: AArch64 Virtual Memory / MMU Implementation

## Overview

Implemented MMU (Memory Management Unit) with identity mapping for the Kenix microkernel running on QEMU virt (Cortex-A72). Identity mapping means virtual addresses equal physical addresses, which is the simplest starting point for enabling paging.

## Architecture Decisions

### TTBR0 Only (for now)
- Using only TTBR0_EL1 for translation
- Kernel runs at low addresses (0x40000000+)
- TTBR1 can be added later for userspace (high addresses)

### 2-Level Page Tables with 2MB Blocks
- 4KB granule size (standard for AArch64)
- L1 entries: each covers 1GB, points to L2 table
- L2 entries: each covers 2MB block (no L3 needed)
- Total: 3 page tables = 12KB memory

### 39-bit Virtual Address Space
- T0SZ = 25 in TCR_EL1 (64 - 25 = 39 bits)
- Translation starts at Level 1 (not Level 0)
- Sufficient for 512GB address space

## Memory Map

```
Virtual = Physical       Size    Type              Purpose
────────────────────────────────────────────────────────────
0x0800_0000              2MB     Device-nGnRnE     GIC (interrupt controller)
0x0900_0000              2MB     Device-nGnRnE     PL011 UART
0x4000_0000 - 0x8000_0000  1GB   Normal WB         RAM (kernel + free memory)
```

Page table structure:
```
L1[0] → L2_DEVICE  (covers 0x00000000 - 0x40000000)
        └─ entry[64]: GIC  at 0x08000000 (Device)
        └─ entry[72]: UART at 0x09000000 (Device)

L1[1] → L2_RAM     (covers 0x40000000 - 0x80000000)
        └─ entries[0-511]: 512 x 2MB blocks (Normal cacheable)
```

## Register Configuration

### MAIR_EL1 (Memory Attribute Indirection Register)
```
Attr0 = 0x00  → Device-nGnRnE (non-Gathering, non-Reordering, no Early write ack)
Attr1 = 0xFF  → Normal Write-Back cacheable (Inner/Outer Write-Back, Read/Write Allocate)
```

### TCR_EL1 (Translation Control Register)
```
T0SZ  = 25      → 39-bit VA for TTBR0
TG0   = 0b00    → 4KB granule
IRGN0 = 0b01    → Inner Write-Back cacheable
ORGN0 = 0b01    → Outer Write-Back cacheable
SH0   = 0b11    → Inner Shareable
EPD1  = 1       → Disable TTBR1 walks
IPS   = 0b010   → 40-bit PA (1TB physical)
```

### SCTLR_EL1 (System Control Register)
```
M = 1  → Enable MMU
C = 1  → Enable data cache
I = 1  → Enable instruction cache
```

## Page Table Entry Format

For 2MB block descriptors at L2:
```
[63:54] Upper attributes (UXN, PXN, etc.)
[53:48] Reserved
[47:21] Output address (2MB aligned)
[20:12] Reserved (SBZ for blocks)
[11]    nG (not Global)
[10]    AF (Access Flag) - must be 1
[9:8]   SH (Shareability)
[7:6]   AP (Access Permissions)
[5]     NS (Non-secure)
[4:2]   AttrIndx (MAIR index)
[1]     Type: 0=block, 1=table
[0]     Valid bit
```

## Enable Sequence

1. Allocate 3 pages from frame allocator (L1, L2_device, L2_ram)
2. Zero all tables using volatile writes
3. Fill L2_device: entries for GIC and UART as Device memory
4. Fill L2_ram: 512 entries for 1GB RAM as Normal memory
5. Fill L1: entry[0] → L2_device, entry[1] → L2_ram
6. `dsb ishst` - ensure page table writes complete
7. Write MAIR_EL1, TCR_EL1, TTBR0_EL1
8. `isb` - instruction barrier
9. `tlbi vmalle1is` - invalidate TLB
10. `dsb ish`, `isb` - barriers
11. Read SCTLR_EL1, set M|C|I bits, write back
12. `isb` - final instruction barrier

## Files Added/Modified

### New: `kernel/src/mm/paging.rs`
- `PageTableEntry` - 64-bit entry with constructors for block/table entries
- `PageTable` - 512-entry array, 4KB aligned
- `l1_index()`, `l2_index()` - VA to index extractors
- Memory attribute constants

### New: `kernel/src/mm/mmu.rs`
- `MAIR_VALUE`, `TCR_VALUE` - register configuration constants
- `init_and_enable()` - main entry point
- System register access functions (mrs/msr wrappers)

### Modified: `kernel/src/mm/mod.rs`
- Added `mod paging` and `mod mmu`
- Exported `enable_mmu()` function

### Modified: `kernel/src/main.rs`
- Calls `mm::enable_mmu()` after frame allocator init
- Prints confirmation message

## Verification

```
Enabling MMU...
  L1 table at: 0x400a0000
  L2 device table at: 0x400a1000
  L2 RAM table at: 0x400a2000
MMU enabled - identity mapping active
  UART: Device-nGnRnE
  RAM: Normal Write-Back cacheable
```

- UART output continues after enable → device mapping works
- Kernel doesn't crash → code/RAM mapping works

## Lessons Learned

1. **T0SZ matters**: Initially used T0SZ=16 (48-bit VA, 4-level), but only set up 2 levels. Changed to T0SZ=25 (39-bit VA, starts at L1) to match our 2-level setup.

2. **Volatile writes required**: Page table writes must use volatile operations to ensure they reach memory before MMU enable. Regular writes might be optimized away or reordered.

3. **Barrier sequence critical**: The exact sequence of DSB/ISB/TLBI instructions matters. Missing barriers cause silent failures or crashes.

## Future Work

- Add TTBR1 for userspace (higher-half kernel)
- Implement dynamic page mapping/unmapping
- Add page fault handler
- Support 4KB pages for fine-grained mapping
