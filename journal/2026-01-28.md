# 2026-01-28: AArch64 Virtual Memory / MMU Implementation

## Overview

Implemented MMU (Memory Management Unit) with identity mapping for the Kenix microkernel running on QEMU virt (Cortex-A72). Identity mapping means virtual addresses equal physical addresses, which is the simplest starting point for enabling paging.

## Architecture Decisions

### TTBR0 Only (for now)
- Using only TTBR0_EL1 for translation
- Kernel runs at low addresses (0x40000000+)
- TTBR1 can be added later for userspace (high addresses)

### 2-Level Page Tables with 2MB Blocks
- 4KB granule size (standard for AArch64)
- L1 entries: each covers 1GB, points to L2 table
- L2 entries: each covers 2MB block (no L3 needed)
- Total: 3 page tables = 12KB memory

### 39-bit Virtual Address Space
- T0SZ = 25 in TCR_EL1 (64 - 25 = 39 bits)
- Translation starts at Level 1 (not Level 0)
- Sufficient for 512GB address space

## Memory Map

```
Virtual = Physical       Size    Type              Purpose
────────────────────────────────────────────────────────────
0x0800_0000              2MB     Device-nGnRnE     GIC (interrupt controller)
0x0900_0000              2MB     Device-nGnRnE     PL011 UART
0x4000_0000 - 0x8000_0000  1GB   Normal WB         RAM (kernel + free memory)
```

Page table structure:
```
L1[0] → L2_DEVICE  (covers 0x00000000 - 0x40000000)
        └─ entry[64]: GIC  at 0x08000000 (Device)
        └─ entry[72]: UART at 0x09000000 (Device)

L1[1] → L2_RAM     (covers 0x40000000 - 0x80000000)
        └─ entries[0-511]: 512 x 2MB blocks (Normal cacheable)
```

## Register Configuration

### MAIR_EL1 (Memory Attribute Indirection Register)
```
Attr0 = 0x00  → Device-nGnRnE (non-Gathering, non-Reordering, no Early write ack)
Attr1 = 0xFF  → Normal Write-Back cacheable (Inner/Outer Write-Back, Read/Write Allocate)
```

### TCR_EL1 (Translation Control Register)
```
T0SZ  = 25      → 39-bit VA for TTBR0
TG0   = 0b00    → 4KB granule
IRGN0 = 0b01    → Inner Write-Back cacheable
ORGN0 = 0b01    → Outer Write-Back cacheable
SH0   = 0b11    → Inner Shareable
EPD1  = 1       → Disable TTBR1 walks
IPS   = 0b010   → 40-bit PA (1TB physical)
```

### SCTLR_EL1 (System Control Register)
```
M = 1  → Enable MMU
C = 1  → Enable data cache
I = 1  → Enable instruction cache
```

## Page Table Entry Format

For 2MB block descriptors at L2:
```
[63:54] Upper attributes (UXN, PXN, etc.)
[53:48] Reserved
[47:21] Output address (2MB aligned)
[20:12] Reserved (SBZ for blocks)
[11]    nG (not Global)
[10]    AF (Access Flag) - must be 1
[9:8]   SH (Shareability)
[7:6]   AP (Access Permissions)
[5]     NS (Non-secure)
[4:2]   AttrIndx (MAIR index)
[1]     Type: 0=block, 1=table
[0]     Valid bit
```

## Enable Sequence

1. Allocate 3 pages from frame allocator (L1, L2_device, L2_ram)
2. Zero all tables using volatile writes
3. Fill L2_device: entries for GIC and UART as Device memory
4. Fill L2_ram: 512 entries for 1GB RAM as Normal memory
5. Fill L1: entry[0] → L2_device, entry[1] → L2_ram
6. `dsb ishst` - ensure page table writes complete
7. Write MAIR_EL1, TCR_EL1, TTBR0_EL1
8. `isb` - instruction barrier
9. `tlbi vmalle1is` - invalidate TLB
10. `dsb ish`, `isb` - barriers
11. Read SCTLR_EL1, set M|C|I bits, write back
12. `isb` - final instruction barrier

## Files Added/Modified

### New: `kernel/src/mm/paging.rs`
- `PageTableEntry` - 64-bit entry with constructors for block/table entries
- `PageTable` - 512-entry array, 4KB aligned
- `l1_index()`, `l2_index()` - VA to index extractors
- Memory attribute constants

### New: `kernel/src/mm/mmu.rs`
- `MAIR_VALUE`, `TCR_VALUE` - register configuration constants
- `init_and_enable()` - main entry point
- System register access functions (mrs/msr wrappers)

### Modified: `kernel/src/mm/mod.rs`
- Added `mod paging` and `mod mmu`
- Exported `enable_mmu()` function

### Modified: `kernel/src/main.rs`
- Calls `mm::enable_mmu()` after frame allocator init
- Prints confirmation message

## Verification

```
Enabling MMU...
  L1 table at: 0x400a0000
  L2 device table at: 0x400a1000
  L2 RAM table at: 0x400a2000
MMU enabled - identity mapping active
  UART: Device-nGnRnE
  RAM: Normal Write-Back cacheable
```

- UART output continues after enable → device mapping works
- Kernel doesn't crash → code/RAM mapping works

## Lessons Learned

1. **T0SZ matters**: Initially used T0SZ=16 (48-bit VA, 4-level), but only set up 2 levels. Changed to T0SZ=25 (39-bit VA, starts at L1) to match our 2-level setup.

2. **Volatile writes required**: Page table writes must use volatile operations to ensure they reach memory before MMU enable. Regular writes might be optimized away or reordered.

3. **Barrier sequence critical**: The exact sequence of DSB/ISB/TLBI instructions matters. Missing barriers cause silent failures or crashes.

## Future Work

- Add TTBR1 for userspace (higher-half kernel)
- Implement dynamic page mapping/unmapping
- ~~Add page fault handler~~ Done (see below)
- Support 4KB pages for fine-grained mapping

---

# 2026-01-28: AArch64 Exception Handling Implementation

## Overview

Implemented exception vector table and handlers for CPU exceptions, interrupts, and syscalls at EL1. This enables the kernel to catch faults (like null pointer dereferences), handle interrupts (future), and process system calls from userspace.

## AArch64 Exception Levels

AArch64 has 4 exception levels (EL0-EL3), each with increasing privilege:

```
EL3  Secure Monitor     (ARM TrustZone, firmware)
EL2  Hypervisor         (virtual machine monitor)
EL1  OS Kernel          ← Kenix runs here
EL0  User Application   (unprivileged)
```

**Key points:**
- Higher EL = more privilege
- Exceptions always go to same or higher EL, never lower
- Each EL has its own stack pointer (SP_EL0, SP_EL1, etc.)
- System registers are suffixed with EL level (e.g., `VBAR_EL1`, `SPSR_EL1`)

## How Exceptions Work

When a CPU exception occurs:

1. **Hardware saves state:**
   - `ELR_ELx` ← PC (return address)
   - `SPSR_ELx` ← PSTATE (saved processor status)
   - `ESR_ELx` ← Exception Syndrome (cause)
   - `FAR_ELx` ← Fault Address (for memory faults)

2. **Hardware jumps to vector:**
   - PC ← `VBAR_ELx + offset` (based on exception type and source)
   - PSTATE updated (interrupts masked, etc.)

3. **Software handler runs:**
   - Save remaining registers (x0-x30, sp)
   - Process exception
   - Restore registers
   - `eret` instruction returns (restores PC and PSTATE)

## Exception Vector Table Structure

The table is 2KB aligned (`VBAR_EL1` must be 0x800-aligned) with 16 entries organized as 4 groups × 4 types:

```
Offset    Exception Type    Source EL / Stack
──────────────────────────────────────────────────────────────
0x000     Synchronous       Current EL, SP_EL0    (unused)
0x080     IRQ               Current EL, SP_EL0    (unused)
0x100     FIQ               Current EL, SP_EL0    (unused)
0x180     SError            Current EL, SP_EL0    (unused)

0x200     Synchronous       Current EL, SP_ELx    ← Kernel faults
0x280     IRQ               Current EL, SP_ELx    ← Kernel IRQ
0x300     FIQ               Current EL, SP_ELx    ← Kernel FIQ
0x380     SError            Current EL, SP_ELx    ← Kernel SError

0x400     Synchronous       Lower EL, AArch64     ← User syscall/fault
0x480     IRQ               Lower EL, AArch64     ← User IRQ
0x500     FIQ               Lower EL, AArch64     ← User FIQ
0x580     SError            Lower EL, AArch64     ← User SError

0x600     Synchronous       Lower EL, AArch32     (unused)
0x680     IRQ               Lower EL, AArch32     (unused)
0x700     FIQ               Lower EL, AArch32     (unused)
0x780     SError            Lower EL, AArch32     (unused)
```

Each entry is 128 bytes (0x80) - enough for a branch or small stub.

**Exception Types:**
- **Synchronous**: CPU-generated, predictable (syscalls, faults, traps)
- **IRQ**: Normal hardware interrupt
- **FIQ**: Fast interrupt (higher priority)
- **SError**: System Error (async, usually fatal - ECC errors, bus faults)

## How MMU Triggers Exceptions

When MMU is enabled and code accesses an invalid address:

1. **CPU performs address translation:**
   - VA → L1 lookup → L2 lookup → PA (or fault)

2. **Translation fault if:**
   - Page table entry is invalid (bit 0 = 0)
   - No mapping exists for the address

3. **Data Abort exception raised:**
   - `ESR_EL1.EC` = 0x25 (Data Abort from current EL)
   - `ESR_EL1.DFSC` = fault status code (e.g., 0x06 = translation fault level 2)
   - `FAR_EL1` = faulting virtual address
   - CPU jumps to `VBAR_EL1 + 0x200` (sync exception, current EL)

**Example: Null pointer dereference**
```rust
unsafe { core::ptr::read_volatile(0 as *const u8); }
```
Results in:
```
ESR_EL1:  0x96000006
          ││    └─── DFSC = 0x06 (translation fault, level 2)
          │└─────── ISS (Instruction Specific Syndrome)
          └──────── EC = 0x25 (Data Abort, current EL)
FAR_EL1:  0x0000000000000000
```

## Exception Syndrome Register (ESR_EL1)

```
[31:26]  EC    Exception Class (type of exception)
[25]     IL    Instruction Length (0=16-bit, 1=32-bit)
[24:0]   ISS   Instruction Specific Syndrome (varies by EC)
```

**Common EC values:**
| EC | Name | Description |
|----|------|-------------|
| 0x00 | Unknown | Unknown reason |
| 0x15 | SVC64 | Supervisor Call from AArch64 (syscall) |
| 0x20 | IABT_LOW | Instruction Abort from lower EL |
| 0x21 | IABT_CUR | Instruction Abort from current EL |
| 0x24 | DABT_LOW | Data Abort from lower EL |
| 0x25 | DABT_CUR | Data Abort from current EL |
| 0x2C | FP | Floating-point exception |
| 0x3C | BRK | Breakpoint instruction |

**Data Fault Status Codes (DFSC, bits [5:0] for data aborts):**
| Code | Meaning |
|------|---------|
| 0x04 | Translation fault, level 0 |
| 0x05 | Translation fault, level 1 |
| 0x06 | Translation fault, level 2 |
| 0x07 | Translation fault, level 3 |
| 0x09 | Access flag fault, level 1 |
| 0x0D | Permission fault, level 1 |
| 0x0E | Permission fault, level 2 |
| 0x0F | Permission fault, level 3 |
| 0x21 | Alignment fault |

## Context Save/Restore

Exception handlers must preserve all registers. Our stack frame (288 bytes):

```
Offset   Content              Size
─────────────────────────────────────
0x000    x0-x30 (GPRs)        248 bytes (31 × 8)
0x0F8    SP (original)        8 bytes
0x100    ELR_EL1 (return PC)  8 bytes
0x108    SPSR_EL1 (status)    8 bytes
0x110    ESR_EL1 (syndrome)   8 bytes
0x118    FAR_EL1 (fault addr) 8 bytes
─────────────────────────────────────
Total:   288 bytes (0x120, 16-byte aligned)
```

Assembly macro flow:
```asm
SAVE_CONTEXT:
    sub     sp, sp, #288        // allocate frame
    stp     x0, x1, [sp, #0x00] // save GPRs
    ...
    mrs     x0, elr_el1         // save system registers
    mrs     x1, spsr_el1
    stp     x0, x1, [sp, #0x100]
    mrs     x0, esr_el1
    mrs     x1, far_el1
    stp     x0, x1, [sp, #0x110]

RESTORE_CONTEXT:
    ldp     x0, x1, [sp, #0x100]
    msr     elr_el1, x0         // restore return address
    msr     spsr_el1, x1        // restore status
    ldp     x0, x1, [sp, #0x00] // restore GPRs
    ...
    add     sp, sp, #288        // deallocate frame
    eret                        // return from exception
```

## Handler Behavior

| Exception | Source | Handler Action |
|-----------|--------|----------------|
| EL1 Sync | Kernel fault | Panic with debug info |
| EL1 IRQ | Hardware interrupt | Panic "not implemented" (needs GIC) |
| EL1 SError | System error | Panic with error info |
| EL0 Sync (SVC) | User syscall | Return -ENOSYS (stub) |
| EL0 Sync (fault) | User fault | Print error, halt (future: SIGSEGV) |
| EL0 IRQ | User interrupted | Same as EL1 IRQ |

## Files Added/Modified

### New: `kernel/src/exception/vectors.s`
- `SAVE_CONTEXT` / `RESTORE_CONTEXT` macros
- 2KB-aligned vector table with 16 entries
- Each active entry saves context, calls Rust handler, restores, `eret`

### New: `kernel/src/exception/context.rs`
- `ExceptionContext` struct matching stack frame layout
- Helper methods: `exception_class()`, `is_svc()`, `is_data_abort()`, `svc_number()`, `fault_status_code()`

### New: `kernel/src/exception/mod.rs`
- `init()` - writes `VBAR_EL1` register
- `vbar_el1()` - reads current value
- `handle_el1_sync/irq/fiq/serror()` - kernel exception handlers
- `handle_el0_sync/irq/fiq/serror()` - user exception handlers

### Modified: `kernel/linker.ld`
```ld
.vectors : ALIGN(0x800) {
    __exception_vectors_start = .;
    *(.text.vectors)
}
```

### Modified: `kernel/build.rs`
- Compiles `vectors.s` alongside `boot.s`

### Modified: `kernel/src/main.rs`
- `mod exception;`
- Calls `exception::init()` after MMU enable

## Verification

Normal boot:
```
Setting up exception vectors...
  VBAR_EL1: 0x0000000040084800
Exception handling ready!
```

Null pointer test:
```
Testing exception handler with null pointer access...

!!! KERNEL EXCEPTION !!!
KERNEL DATA ABORT!
Faulting address: 0x0000000000000000
  Exception Class: Data abort (current EL) (0x25)
  ESR_EL1:  0x0000000096000006
  ELR_EL1:  0x0000000040083d7c
  SPSR_EL1: 0x00000000600003c5
  FAR_EL1:  0x0000000000000000
  SP:       0x00000000400a0f80
  Fault: Translation fault, level 2 (read)
```

## Future Work

- ~~Implement GIC driver for IRQ handling~~ Done (see below)
- ~~Add syscall dispatch table~~ Done (see below)
- User process signal delivery (SIGSEGV, etc.)
- Nested exception handling (currently handlers just panic/halt)

---

# 2026-01-28: Preemptive Round-Robin Scheduler

## Overview

Implemented a preemptive scheduler that uses timer interrupts to switch between kernel tasks. This required integrating several components: GICv2 interrupt controller, ARM Generic Timer, and a context switching mechanism that works with the existing exception handling infrastructure.

## Architecture

### Scheduling Strategy

- **Round-robin** with time slices (1 tick = 10ms default)
- **Preemptive**: Timer IRQ triggers reschedule when time slice expires
- **Cooperative yield** also supported (for future use)
- **Single-core only** (SMP extension planned)

### Task Structure

```rust
pub struct Task {
    pub id: TaskId,
    pub state: TaskState,          // Free, Ready, Running, Blocked, Terminated
    pub kernel_stack_base: PhysAddr,
    pub kernel_stack_top: usize,   // Saved SP pointing to ExceptionContext
    pub page_table: PhysAddr,      // TTBR0_EL1 (0 = kernel table)
    pub entry_point: usize,
    pub time_slice: u32,
    pub next: Option<TaskId>,      // Ready queue linked list
}
```

### Context Switch Flow

The key insight is that we reuse the exception handling infrastructure for context switching:

```
1. Timer IRQ fires while task A runs
2. Vector entry → SAVE_CONTEXT (saves A's registers to A's stack)
3. handle_el1_irq() called with ctx pointing to saved context
4. tick() returns true (time slice expired, ready queue not empty)
5. context_switch():
   - Save A's SP (points to its ExceptionContext)
   - Enqueue A to ready queue
   - Dequeue B from ready queue
   - Call switch_context_and_restore(B's SP)
6. switch_context_and_restore:
   - Set SP = B's saved context
   - RESTORE_CONTEXT (loads B's registers)
   - ERET (returns to B's saved ELR with B's SPSR)
```

### New Task Setup

When creating a task, we set up a **fake ExceptionContext** on its stack:

```rust
// At stack_top - 288 bytes:
(*ctx).elr = entry_point as u64;  // Where ERET will jump
(*ctx).spsr = 0x305;              // EL1h, IRQs enabled
(*ctx).sp = ctx_addr as u64;      // Initial stack pointer
// All GPRs zeroed
```

When the scheduler first switches to this task, RESTORE_CONTEXT pops this fake context and ERET jumps to the entry point.

## Key Components

### GIC Driver (`gic.rs`)

GICv2 for QEMU virt machine:

```
GICD (Distributor): 0x0800_0000
GICC (CPU Interface): 0x0801_0000
```

Key operations:
- `init()`: Enable distributor and CPU interface
- `enable_irq(30)`: Enable timer IRQ (PPI ID 30)
- `acknowledge()`: Read GICC_IAR, get IRQ number
- `end_of_interrupt(irq)`: Write GICC_EOIR, signal completion

### Timer (`timer.rs`)

ARM Generic Timer using system registers:

```
CNTFRQ_EL0:  Timer frequency (62.5 MHz on QEMU)
CNTP_CTL_EL0: Control (enable, mask)
CNTP_TVAL_EL0: Countdown value
```

- `start(interval_ms)`: Set countdown = frequency * interval / 1000, enable
- `acknowledge_and_reset()`: Re-arm timer for next tick

### Scheduler (`sched/mod.rs`)

Ready queue as linked list:
- `enqueue(id)`: Add to tail, O(1)
- `dequeue()`: Remove from head, O(1)
- `tick()`: Decrement time_slice, return true if reschedule needed

### Assembly Helper (`vectors.s`)

```asm
.global switch_context_and_restore
switch_context_and_restore:
    mov     sp, x0          // Set SP to new task's saved context
    RESTORE_CONTEXT         // Restore all registers, ERET
```

This function **never returns** - it switches stack and does ERET directly.

## Critical Bugs Fixed

### 1. Vector Table Entry Overflow

**Problem**: Each vector entry is only 128 bytes (0x80), but SAVE_CONTEXT + handler + RESTORE_CONTEXT expanded to ~200 bytes, causing entries to overflow into adjacent entries.

**Symptom**: Data abort at 0x80000000 before IRQ handler even ran.

**Fix**: Each vector entry just branches to handler code located outside the table:
```asm
.balign 0x80
    b       el1_irq_handler   // 0x280: IRQ

// ... after table ...
el1_irq_handler:
    SAVE_CONTEXT
    bl      handle_el1_irq
    RESTORE_CONTEXT
```

### 2. EOI Before Context Switch

**Problem**: `switch_context_and_restore` never returns (does ERET), so `gic::end_of_interrupt()` was never called after a context switch. GIC wouldn't deliver more interrupts.

**Symptom**: Only one timer tick, then silence.

**Fix**: Call EOI before context switch:
```rust
if irq == TIMER_IRQ {
    timer::acknowledge_and_reset();
    let needs_switch = sched::tick();
    gic::end_of_interrupt(irq);  // EOI BEFORE switch
    if needs_switch {
        context_switch(ctx);      // May not return
    }
}
```

### 3. Return Address on Wrong Stack

**Problem**: When `context_switch` changed SP and then returned via normal Rust epilogue, it tried to load the return address from the new task's stack (garbage).

**Symptom**: Instruction abort at address 0x0000000000000000.

**Fix**: Don't return from context_switch normally. Call assembly function that sets SP and does ERET directly:
```rust
// Instead of:
// asm!("mov sp, {}", new_sp);  // then return (broken!)

// Do:
switch_context_and_restore(new_sp);  // Never returns
```

## Files Added/Modified

### New Files

| File | Purpose |
|------|---------|
| `kernel/src/gic.rs` | GICv2 interrupt controller driver |
| `kernel/src/timer.rs` | ARM Generic Timer driver |
| `kernel/src/sched/mod.rs` | Scheduler core, context_switch |
| `kernel/src/sched/task.rs` | Task structure, ready queue |
| `kernel/src/syscall.rs` | Syscall dispatcher stub |

### Modified Files

| File | Changes |
|------|---------|
| `kernel/src/exception/vectors.s` | Moved handlers outside table, added `switch_context_and_restore` |
| `kernel/src/exception/mod.rs` | IRQ handler calls scheduler |
| `kernel/src/main.rs` | Init GIC, timer, scheduler; create test tasks |

## SPSR Configuration

For new tasks (start in EL1 with interrupts enabled):

```
SPSR = 0x305 = 0b0011_0000_0101

Bits:
[3:0]  M    = 0101 (EL1h - using SP_EL1)
[4]    M    = 0
[6]    F    = 0 (FIQ enabled)
[7]    I    = 0 (IRQ enabled)
[8]    A    = 1 (SError masked)
[9]    D    = 1 (Debug masked)
```

## Verification

```
Starting scheduler...
AAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAA
BBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBB
AAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAA
...
```

- Tasks A and B alternate (round-robin)
- Each runs for one time slice before preemption
- Idle task (0) runs when both yield or block

## Syscalls (Stub)

| Number | Name | Current Behavior |
|--------|------|------------------|
| 0 | SYS_YIELD | Calls `sched::yield_cpu()` |
| 1 | SYS_EXIT | Calls `sched::exit()` |
| * | Unknown | Returns -ENOSYS |

## Future Work

- Per-task page tables (TTBR0 switch in context_switch)
- Priority-based scheduling
- Blocking wait queues (for IPC, I/O)
- SMP support (per-CPU schedulers, IPIs)
- Real-time scheduling classes
