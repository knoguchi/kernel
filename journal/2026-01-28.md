# 2026-01-28: AArch64 Virtual Memory / MMU Implementation

## Overview

Implemented MMU (Memory Management Unit) with identity mapping for the Kenix microkernel running on QEMU virt (Cortex-A72). Identity mapping means virtual addresses equal physical addresses, which is the simplest starting point for enabling paging.

## Architecture Decisions

### TTBR0 Only (for now)
- Using only TTBR0_EL1 for translation
- Kernel runs at low addresses (0x40000000+)
- TTBR1 can be added later for userspace (high addresses)

### 2-Level Page Tables with 2MB Blocks
- 4KB granule size (standard for AArch64)
- L1 entries: each covers 1GB, points to L2 table
- L2 entries: each covers 2MB block (no L3 needed)
- Total: 3 page tables = 12KB memory

### 39-bit Virtual Address Space
- T0SZ = 25 in TCR_EL1 (64 - 25 = 39 bits)
- Translation starts at Level 1 (not Level 0)
- Sufficient for 512GB address space

## Memory Map

```
Virtual = Physical       Size    Type              Purpose
────────────────────────────────────────────────────────────
0x0800_0000              2MB     Device-nGnRnE     GIC (interrupt controller)
0x0900_0000              2MB     Device-nGnRnE     PL011 UART
0x4000_0000 - 0x8000_0000  1GB   Normal WB         RAM (kernel + free memory)
```

Page table structure:
```
L1[0] → L2_DEVICE  (covers 0x00000000 - 0x40000000)
        └─ entry[64]: GIC  at 0x08000000 (Device)
        └─ entry[72]: UART at 0x09000000 (Device)

L1[1] → L2_RAM     (covers 0x40000000 - 0x80000000)
        └─ entries[0-511]: 512 x 2MB blocks (Normal cacheable)
```

## Register Configuration

### MAIR_EL1 (Memory Attribute Indirection Register)
```
Attr0 = 0x00  → Device-nGnRnE (non-Gathering, non-Reordering, no Early write ack)
Attr1 = 0xFF  → Normal Write-Back cacheable (Inner/Outer Write-Back, Read/Write Allocate)
```

### TCR_EL1 (Translation Control Register)
```
T0SZ  = 25      → 39-bit VA for TTBR0
TG0   = 0b00    → 4KB granule
IRGN0 = 0b01    → Inner Write-Back cacheable
ORGN0 = 0b01    → Outer Write-Back cacheable
SH0   = 0b11    → Inner Shareable
EPD1  = 1       → Disable TTBR1 walks
IPS   = 0b010   → 40-bit PA (1TB physical)
```

### SCTLR_EL1 (System Control Register)
```
M = 1  → Enable MMU
C = 1  → Enable data cache
I = 1  → Enable instruction cache
```

## Page Table Entry Format

For 2MB block descriptors at L2:
```
[63:54] Upper attributes (UXN, PXN, etc.)
[53:48] Reserved
[47:21] Output address (2MB aligned)
[20:12] Reserved (SBZ for blocks)
[11]    nG (not Global)
[10]    AF (Access Flag) - must be 1
[9:8]   SH (Shareability)
[7:6]   AP (Access Permissions)
[5]     NS (Non-secure)
[4:2]   AttrIndx (MAIR index)
[1]     Type: 0=block, 1=table
[0]     Valid bit
```

## Enable Sequence

1. Allocate 3 pages from frame allocator (L1, L2_device, L2_ram)
2. Zero all tables using volatile writes
3. Fill L2_device: entries for GIC and UART as Device memory
4. Fill L2_ram: 512 entries for 1GB RAM as Normal memory
5. Fill L1: entry[0] → L2_device, entry[1] → L2_ram
6. `dsb ishst` - ensure page table writes complete
7. Write MAIR_EL1, TCR_EL1, TTBR0_EL1
8. `isb` - instruction barrier
9. `tlbi vmalle1is` - invalidate TLB
10. `dsb ish`, `isb` - barriers
11. Read SCTLR_EL1, set M|C|I bits, write back
12. `isb` - final instruction barrier

## Files Added/Modified

### New: `kernel/src/mm/paging.rs`
- `PageTableEntry` - 64-bit entry with constructors for block/table entries
- `PageTable` - 512-entry array, 4KB aligned
- `l1_index()`, `l2_index()` - VA to index extractors
- Memory attribute constants

### New: `kernel/src/mm/mmu.rs`
- `MAIR_VALUE`, `TCR_VALUE` - register configuration constants
- `init_and_enable()` - main entry point
- System register access functions (mrs/msr wrappers)

### Modified: `kernel/src/mm/mod.rs`
- Added `mod paging` and `mod mmu`
- Exported `enable_mmu()` function

### Modified: `kernel/src/main.rs`
- Calls `mm::enable_mmu()` after frame allocator init
- Prints confirmation message

## Verification

```
Enabling MMU...
  L1 table at: 0x400a0000
  L2 device table at: 0x400a1000
  L2 RAM table at: 0x400a2000
MMU enabled - identity mapping active
  UART: Device-nGnRnE
  RAM: Normal Write-Back cacheable
```

- UART output continues after enable → device mapping works
- Kernel doesn't crash → code/RAM mapping works

## Lessons Learned

1. **T0SZ matters**: Initially used T0SZ=16 (48-bit VA, 4-level), but only set up 2 levels. Changed to T0SZ=25 (39-bit VA, starts at L1) to match our 2-level setup.

2. **Volatile writes required**: Page table writes must use volatile operations to ensure they reach memory before MMU enable. Regular writes might be optimized away or reordered.

3. **Barrier sequence critical**: The exact sequence of DSB/ISB/TLBI instructions matters. Missing barriers cause silent failures or crashes.

## Future Work

- Add TTBR1 for userspace (higher-half kernel)
- Implement dynamic page mapping/unmapping
- ~~Add page fault handler~~ Done (see below)
- Support 4KB pages for fine-grained mapping

---

# 2026-01-28: AArch64 Exception Handling Implementation

## Overview

Implemented exception vector table and handlers for CPU exceptions, interrupts, and syscalls at EL1. This enables the kernel to catch faults (like null pointer dereferences), handle interrupts (future), and process system calls from userspace.

## AArch64 Exception Levels

AArch64 has 4 exception levels (EL0-EL3), each with increasing privilege:

```
EL3  Secure Monitor     (ARM TrustZone, firmware)
EL2  Hypervisor         (virtual machine monitor)
EL1  OS Kernel          ← Kenix runs here
EL0  User Application   (unprivileged)
```

**Key points:**
- Higher EL = more privilege
- Exceptions always go to same or higher EL, never lower
- Each EL has its own stack pointer (SP_EL0, SP_EL1, etc.)
- System registers are suffixed with EL level (e.g., `VBAR_EL1`, `SPSR_EL1`)

## How Exceptions Work

When a CPU exception occurs:

1. **Hardware saves state:**
   - `ELR_ELx` ← PC (return address)
   - `SPSR_ELx` ← PSTATE (saved processor status)
   - `ESR_ELx` ← Exception Syndrome (cause)
   - `FAR_ELx` ← Fault Address (for memory faults)

2. **Hardware jumps to vector:**
   - PC ← `VBAR_ELx + offset` (based on exception type and source)
   - PSTATE updated (interrupts masked, etc.)

3. **Software handler runs:**
   - Save remaining registers (x0-x30, sp)
   - Process exception
   - Restore registers
   - `eret` instruction returns (restores PC and PSTATE)

## Exception Vector Table Structure

The table is 2KB aligned (`VBAR_EL1` must be 0x800-aligned) with 16 entries organized as 4 groups × 4 types:

```
Offset    Exception Type    Source EL / Stack
──────────────────────────────────────────────────────────────
0x000     Synchronous       Current EL, SP_EL0    (unused)
0x080     IRQ               Current EL, SP_EL0    (unused)
0x100     FIQ               Current EL, SP_EL0    (unused)
0x180     SError            Current EL, SP_EL0    (unused)

0x200     Synchronous       Current EL, SP_ELx    ← Kernel faults
0x280     IRQ               Current EL, SP_ELx    ← Kernel IRQ
0x300     FIQ               Current EL, SP_ELx    ← Kernel FIQ
0x380     SError            Current EL, SP_ELx    ← Kernel SError

0x400     Synchronous       Lower EL, AArch64     ← User syscall/fault
0x480     IRQ               Lower EL, AArch64     ← User IRQ
0x500     FIQ               Lower EL, AArch64     ← User FIQ
0x580     SError            Lower EL, AArch64     ← User SError

0x600     Synchronous       Lower EL, AArch32     (unused)
0x680     IRQ               Lower EL, AArch32     (unused)
0x700     FIQ               Lower EL, AArch32     (unused)
0x780     SError            Lower EL, AArch32     (unused)
```

Each entry is 128 bytes (0x80) - enough for a branch or small stub.

**Exception Types:**
- **Synchronous**: CPU-generated, predictable (syscalls, faults, traps)
- **IRQ**: Normal hardware interrupt
- **FIQ**: Fast interrupt (higher priority)
- **SError**: System Error (async, usually fatal - ECC errors, bus faults)

## How MMU Triggers Exceptions

When MMU is enabled and code accesses an invalid address:

1. **CPU performs address translation:**
   - VA → L1 lookup → L2 lookup → PA (or fault)

2. **Translation fault if:**
   - Page table entry is invalid (bit 0 = 0)
   - No mapping exists for the address

3. **Data Abort exception raised:**
   - `ESR_EL1.EC` = 0x25 (Data Abort from current EL)
   - `ESR_EL1.DFSC` = fault status code (e.g., 0x06 = translation fault level 2)
   - `FAR_EL1` = faulting virtual address
   - CPU jumps to `VBAR_EL1 + 0x200` (sync exception, current EL)

**Example: Null pointer dereference**
```rust
unsafe { core::ptr::read_volatile(0 as *const u8); }
```
Results in:
```
ESR_EL1:  0x96000006
          ││    └─── DFSC = 0x06 (translation fault, level 2)
          │└─────── ISS (Instruction Specific Syndrome)
          └──────── EC = 0x25 (Data Abort, current EL)
FAR_EL1:  0x0000000000000000
```

## Exception Syndrome Register (ESR_EL1)

```
[31:26]  EC    Exception Class (type of exception)
[25]     IL    Instruction Length (0=16-bit, 1=32-bit)
[24:0]   ISS   Instruction Specific Syndrome (varies by EC)
```

**Common EC values:**
| EC | Name | Description |
|----|------|-------------|
| 0x00 | Unknown | Unknown reason |
| 0x15 | SVC64 | Supervisor Call from AArch64 (syscall) |
| 0x20 | IABT_LOW | Instruction Abort from lower EL |
| 0x21 | IABT_CUR | Instruction Abort from current EL |
| 0x24 | DABT_LOW | Data Abort from lower EL |
| 0x25 | DABT_CUR | Data Abort from current EL |
| 0x2C | FP | Floating-point exception |
| 0x3C | BRK | Breakpoint instruction |

**Data Fault Status Codes (DFSC, bits [5:0] for data aborts):**
| Code | Meaning |
|------|---------|
| 0x04 | Translation fault, level 0 |
| 0x05 | Translation fault, level 1 |
| 0x06 | Translation fault, level 2 |
| 0x07 | Translation fault, level 3 |
| 0x09 | Access flag fault, level 1 |
| 0x0D | Permission fault, level 1 |
| 0x0E | Permission fault, level 2 |
| 0x0F | Permission fault, level 3 |
| 0x21 | Alignment fault |

## Context Save/Restore

Exception handlers must preserve all registers. Our stack frame (288 bytes):

```
Offset   Content              Size
─────────────────────────────────────
0x000    x0-x30 (GPRs)        248 bytes (31 × 8)
0x0F8    SP (original)        8 bytes
0x100    ELR_EL1 (return PC)  8 bytes
0x108    SPSR_EL1 (status)    8 bytes
0x110    ESR_EL1 (syndrome)   8 bytes
0x118    FAR_EL1 (fault addr) 8 bytes
─────────────────────────────────────
Total:   288 bytes (0x120, 16-byte aligned)
```

Assembly macro flow:
```asm
SAVE_CONTEXT:
    sub     sp, sp, #288        // allocate frame
    stp     x0, x1, [sp, #0x00] // save GPRs
    ...
    mrs     x0, elr_el1         // save system registers
    mrs     x1, spsr_el1
    stp     x0, x1, [sp, #0x100]
    mrs     x0, esr_el1
    mrs     x1, far_el1
    stp     x0, x1, [sp, #0x110]

RESTORE_CONTEXT:
    ldp     x0, x1, [sp, #0x100]
    msr     elr_el1, x0         // restore return address
    msr     spsr_el1, x1        // restore status
    ldp     x0, x1, [sp, #0x00] // restore GPRs
    ...
    add     sp, sp, #288        // deallocate frame
    eret                        // return from exception
```

## Handler Behavior

| Exception | Source | Handler Action |
|-----------|--------|----------------|
| EL1 Sync | Kernel fault | Panic with debug info |
| EL1 IRQ | Hardware interrupt | Panic "not implemented" (needs GIC) |
| EL1 SError | System error | Panic with error info |
| EL0 Sync (SVC) | User syscall | Return -ENOSYS (stub) |
| EL0 Sync (fault) | User fault | Print error, halt (future: SIGSEGV) |
| EL0 IRQ | User interrupted | Same as EL1 IRQ |

## Files Added/Modified

### New: `kernel/src/exception/vectors.s`
- `SAVE_CONTEXT` / `RESTORE_CONTEXT` macros
- 2KB-aligned vector table with 16 entries
- Each active entry saves context, calls Rust handler, restores, `eret`

### New: `kernel/src/exception/context.rs`
- `ExceptionContext` struct matching stack frame layout
- Helper methods: `exception_class()`, `is_svc()`, `is_data_abort()`, `svc_number()`, `fault_status_code()`

### New: `kernel/src/exception/mod.rs`
- `init()` - writes `VBAR_EL1` register
- `vbar_el1()` - reads current value
- `handle_el1_sync/irq/fiq/serror()` - kernel exception handlers
- `handle_el0_sync/irq/fiq/serror()` - user exception handlers

### Modified: `kernel/linker.ld`
```ld
.vectors : ALIGN(0x800) {
    __exception_vectors_start = .;
    *(.text.vectors)
}
```

### Modified: `kernel/build.rs`
- Compiles `vectors.s` alongside `boot.s`

### Modified: `kernel/src/main.rs`
- `mod exception;`
- Calls `exception::init()` after MMU enable

## Verification

Normal boot:
```
Setting up exception vectors...
  VBAR_EL1: 0x0000000040084800
Exception handling ready!
```

Null pointer test:
```
Testing exception handler with null pointer access...

!!! KERNEL EXCEPTION !!!
KERNEL DATA ABORT!
Faulting address: 0x0000000000000000
  Exception Class: Data abort (current EL) (0x25)
  ESR_EL1:  0x0000000096000006
  ELR_EL1:  0x0000000040083d7c
  SPSR_EL1: 0x00000000600003c5
  FAR_EL1:  0x0000000000000000
  SP:       0x00000000400a0f80
  Fault: Translation fault, level 2 (read)
```

## Future Work

- Implement GIC driver for IRQ handling
- Add syscall dispatch table
- User process signal delivery (SIGSEGV, etc.)
- Nested exception handling (currently handlers just panic/halt)
