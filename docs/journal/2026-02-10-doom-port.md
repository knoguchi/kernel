# DOOM Port to Kenix

**Date:** 2026-02-10

## Overview

Ported the original DOOM (linuxdoom-1.10) to run on Kenix. The game renders
at 320x200 scaled to 640x400 on the framebuffer, with keyboard input via the
console server's non-blocking read.

## Challenges and Solutions

### 1. 64-bit Pointer Size Mismatch in Defaults System

**Problem:** The game's `screenblocks` variable was being set to 0, causing
`viewwidth=0` and `viewheight=0` - the 3D view wasn't rendering at all.

**Root Cause:** The defaults system in `m_misc.c` used `int*` for the location
field, but Kenix's m_misc_kenix.c used `intptr_t*`. On ARM64 (LP64):
- `int` = 4 bytes
- `intptr_t` = 8 bytes

When storing defaults, the code wrote 8-byte values to 4-byte int locations:

```c
// Memory layout in m_menu.c:
int detailLevel;    // at address X
int screenblocks;   // at address X+4

// When M_LoadDefaults writes:
*(intptr_t*)&screenblocks = 9;  // Writes 8 bytes at X+4
*(intptr_t*)&detailLevel = 0;   // Writes 8 bytes at X, corrupting X+4!
```

The second write to `detailLevel` (8 bytes starting at X) overwrote the
previously written `screenblocks` at X+4.

**Fix:** Added `isstring` field to distinguish int vs string defaults:

```c
typedef struct {
    char*    name;
    void*    location;
    intptr_t defaultvalue;
    int      scantranslate;
    int      untranslated;
    int      isstring;      // NEW: 1 for char*, 0 for int
} default_t;

// Proper type-aware writes:
if (defaults[i].isstring) {
    *(char**)defaults[i].location = (char*)defaults[i].defaultvalue;
} else {
    *(int*)defaults[i].location = (int)defaults[i].defaultvalue;  // 4 bytes
}
```

### 2. Blocking stdin Read Freezing Game Loop

**Problem:** The game loop hung after printing `[doom] loop 1`.

**Root Cause:** `I_GetEvent()` called `read(0, &c, 1)` which sent `MSG_READ`
to the console server. The console server's `console_read()` blocks until
at least one character is available - correct for shell input, but deadly
for a game loop that needs to poll without blocking.

**Fix:** Added `MSG_READ_NONBLOCK` (302) to the console server:

```rust
fn console_read_nonblock(buf: &mut [u8]) -> usize {
    let mut count = 0;
    while count < buf.len() {
        if let Some(c) = try_getc() {
            buf[count] = c;
            count += 1;
        } else {
            break;  // Return immediately when no data
        }
    }
    count
}
```

DOOM's `I_GetEvent()` uses direct IPC instead of `read()`:

```c
msg.tag = MSG_READ_NONBLOCK;
msg.data[0] = 8;  // max bytes
ipc_call(TASK_CONSOLE, &msg);
int bytes_read = (int)msg.tag;
if (bytes_read <= 0) return;  // No input, continue game loop
```

### 3. Arrow Keys Not Working

**Problem:** Arrow keys triggered wrong actions or nothing at all.

**Root Cause:** Terminal arrow keys send ANSI escape sequences:
- Up:    ESC [ A (0x1B 0x5B 0x41)
- Down:  ESC [ B
- Left:  ESC [ D
- Right: ESC [ C

The original code processed bytes individually, so Up arrow generated
`KEY_ESCAPE`, `[`, `a` instead of `KEY_UPARROW`.

**Fix:** Added escape sequence state machine:

```c
static int escape_state = 0;  // 0=normal, 1=saw ESC, 2=saw ESC[

static int process_escape_seq(unsigned char c) {
    switch (escape_state) {
        case 0:
            if (c == 0x1B) { escape_state = 1; return -1; }
            return translate_key(c);
        case 1:
            escape_state = 0;
            if (c == '[') { escape_state = 2; return -1; }
            return translate_key(c);
        case 2:
            escape_state = 0;
            switch (c) {
                case 'A': return KEY_UPARROW;
                case 'B': return KEY_DOWNARROW;
                case 'C': return KEY_RIGHTARROW;
                case 'D': return KEY_LEFTARROW;
                default: return -1;
            }
    }
}
```

### 4. Kernel Page Fault During IPC Data Copy

**Problem:** When VFS replied to a read request, copying data to the caller's
buffer could page fault if the buffer was in an unmapped mmap region.

**Root Cause:** The kernel's `handle_page_fault()` only handled faults for
the currently scheduled task, but during IPC reply, the faulting address
belongs to the blocked caller (a different task).

**Fix:** Added `handle_page_fault_for_task()` and `ensure_user_pages_mapped()`:

```rust
pub fn handle_page_fault_for_task(fault_addr: usize, task_id: TaskId) -> i64 {
    // ... fault in page for specified task, not current task
}

pub fn ensure_user_pages_mapped(addr: usize, len: usize, task_id: TaskId) -> i64 {
    // Pre-fault all pages in range before accessing cross-task memory
}
```

## Files Modified

**Kernel:**
- `kernel/src/mmap.rs` - Cross-task page fault handling
- `kernel/src/syscall.rs` - SYS_LSEEK, improved SYS_FACCESSAT
- `kernel/src/exception/mod.rs` - More alignment fault emulations

**User-space:**
- `user/console/src/main.rs` - MSG_READ_NONBLOCK handler
- `user/doom/i_video_kenix.c` - Framebuffer, keyboard, escape sequences
- `user/doom/i_system_kenix.c` - Timing via I_GetTime()
- `user/doom/m_misc_kenix.c` - 64-bit safe defaults system

## Build and Run

```bash
cd user/doom
make
mcopy -o -i ../../disk.img doom.elf ::/doom
mcopy -o -i ../../disk.img doom1.wad ::/doom1.wad
cd ../..
make run-kernel-fb

# In shell:
/ # /disk/doom -iwad /disk/doom1.wad
```

## Controls

- **WASD** or **Arrow keys**: Movement
- **F**: Fire (mapped to Ctrl)
- **E** or **Space**: Use/Open doors
- **Q**: Strafe (mapped to Alt)
- **1-7**: Weapon select
- **ESC**: Menu

## Lessons Learned

1. **64-bit porting is subtle**: Data type sizes matter. `intptr_t` is not
   a drop-in replacement for `int*` when the pointee is `int`.

2. **Game loops need non-blocking I/O**: Blocking reads work for shells but
   kill game loops. Adding MSG_READ_NONBLOCK was essential.

3. **Terminal escape sequences are multi-byte**: Can't process keyboard input
   byte-by-byte when arrow keys send 3-byte sequences.

4. **Cross-task memory access in microkernels**: When server replies to client,
   the client's memory might not be mapped yet. Need to handle page faults
   for tasks other than the currently scheduled one.
